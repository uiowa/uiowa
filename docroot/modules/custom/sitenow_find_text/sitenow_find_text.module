<?php

/**
 * @file
 * Primary module hooks for Sitenow Find Text module.
 *
 * @DCG
 * This file is no longer required in Drupal 8.
 * @see https://www.drupal.org/node/2217931
 */

use Drupal\Core\Entity\Sql\SqlContentEntityStorageException;
use Drupal\Core\Database\Database;

/**
 * Grab field tables and value mappings for all text-based fields.
 *
 * @return array
 *   The field names => info mapping for all text-based fields.
 */
function get_text_field_tables() {
  $entity_field_manager = \Drupal::service('entity_field.manager');
  $entity_type_manager = \Drupal::entityTypeManager();
  $fields = [];
  $tables = [];
  // Go through all our text-based field types,
  // get their field information, and bundle 'em.
  foreach (['string', 'string_long', 'text_long', 'text_with_summary', 'link'] as $type) {
    $new_fields = $entity_field_manager->getFieldMapByFieldType($type);
    foreach ($new_fields as $bundle => $bundle_fields) {
      $fields[$bundle] = isset($fields[$bundle]) ? array_merge($fields[$bundle], $bundle_fields) : $bundle_fields;
    }
  }
  foreach ($fields as $entity_type_id => $field_map) {
    // Currently we're only searching the major content areas.
    // This will leave out things like menu areas, taxonomies, etc.
    // which we may want to add later.
    if (!in_array($entity_type_id, ['block_content', 'node', 'paragraph'])) {
      continue;
    }
    // Grab the storage, field, and table definitions/mappings.
    $entity_storage = $entity_type_manager->getStorage($entity_type_id);
    $field_storage_definitions = $entity_field_manager->getFieldStorageDefinitions($entity_type_id);
    $table_mapping = $entity_storage->getTableMapping($field_storage_definitions);
    foreach (array_intersect_key($field_storage_definitions, $field_map) as $field_storage_definition) {
      $field_name = $field_storage_definition->getName();
      try {
        $table_name = $table_mapping->getFieldTableName($field_name);
        // We use a custom value function here. The built-in value fetcher
        // will leave out extra columns for link and text_with_summary fields.
        $value_columns = value_columns($field_name, $field_storage_definition->getType());
        $parent_type = ['entity_id', 'revision_id'];
        // Titles are handled a little differently, and at this time
        // are the only fields handled this way.
        if ($field_name == 'title') {
          $parent_type = ['nid'];
          $value_columns = ['title'];
        }
        // Set our table info that will get used in various places later.
        $tables[$table_name] = [
          'values' => $value_columns,
          'parent' => $parent_type,
          'type' => $entity_type_id,
          'field_name' => $field_name,
        ];
      }
      catch (SqlContentEntityStorageException $e) {
        continue;
      }
    }
  }
  // This function can be used to clean up some extra tables
  // that don't need to be traversed. This is an easy way
  // to avoid issues down the line later.
  cleanup_tables($tables);
  return $tables;
}

/**
 * Search all fields for a needle.
 *
 * @param string $needle
 *   The string for which to search.
 * @param bool $regexed
 *   Whether a regex condition should be used over base LIKE.
 *
 * @return array
 *   The search results.
 */
function search_fields(string $needle, bool $regexed = FALSE) {
  $results = [];
  $tables = get_text_field_tables();
  $db = Database::getConnection();
  foreach ($tables as $table => $details) {
    $value_columns = $details['values'];
    $parent = $details['parent'];
    $query = $db->select($table)
      ->fields($table, array_merge($parent, $value_columns));
    foreach ($value_columns as $value_column) {
      if ($regexed) {
        $query->condition($table . '.' . $value_column, $needle, 'REGEXP');
      }
      else {
        // Note: We are not using $db->escapeLike($needle) here,
        // at least currently to allow for the option of
        // including wildcards in the provided string.
        // Otherwise we may need to include extra options,
        // such as a non-escaped option, or specifying word boundaries.
        $query->condition($table . '.' . $value_column, '%' . $needle . '%', 'LIKE');
      }
    }
    $temp_results = $query->execute()
      ->fetchAllAssoc($parent[0]);
    // If we don't have results, hop out of this loop early.
    if (empty($temp_results)) {
      continue;
    }
    foreach ($temp_results as &$row) {
      $row->value = implode(': ', [$details['field_name'], $row->$value_column]);
    }
    // If the table is of a node type, we're done. Otherwise, we need
    // to find the parent.
    $temp_results = fetch_parents($temp_results, $details);

    // Add our new results to our collected results, keyed
    // by node id.
    foreach ($temp_results as $nid => $value) {
      $results[$nid][] = $value;
    }
  }
  return $results;
}

/**
 * Helper function to construct field value column names.
 *
 * @param string $name
 *   The field name.
 * @param string $type
 *   The type of field.
 *
 * @return string[]
 *   An array of value columns to retreive from the database table.
 */
function value_columns(string $name, string $type) {
  // @todo Check if we need to handle any of the other
  //   field types differently.
  if ($type == 'link') {
    return [
      $name . '_uri',
      $name . '_title',
    ];
  }
  if ($type == 'text_with_summary') {
    return [
      $name . '_value',
      $name . '_summary',
    ];
  }
  return [$name . '_value'];
}

/**
 * Helper function to remove some errant tables.
 *
 * @param array $tables
 *   List of tables to clean up.
 */
function cleanup_tables(array &$tables) {
  // At this time, these tables are not needed,
  // and will lead to errors in how we grab the value columns
  // later on in the process.
  foreach ([
    'block_content_revision',
    'block_content_field_data',
    'node_revision',
    'paragraphs_item_field_data',
  ] as $to_remove) {
    if (isset($tables[$to_remove])) {
      unset($tables[$to_remove]);
    }
  }
}

/**
 * Helper function to fetch parent entities.
 *
 * @param array $temp_results
 *   The original search results, including child entity info.
 * @param array $details
 *   Details regarding the type of entity we're working with.
 */
function fetch_parents(array $temp_results, array $details) {
  $db = Database::getConnection();
  switch ($details['type']) {
    case 'paragraph':
      $with_nid = [];
      foreach ($temp_results as $target_id => $value) {
        $target_type = $details['type'];
        // We need to loop through it, as we may have nested entities,
        // like a paragraph under a block under a node.
        while (TRUE) {
          // Find the target_id, which will be the id of the parent entity.
          $nid = $db->select('entity_usage')
            ->fields('entity_usage', ['source_id', 'source_type'])
            ->condition('target_type', $target_type, '=')
            ->condition('target_id', $target_id, '=')
            // Currently we're not handling revisions, so we're likely to have
            // duplicate entries for the same node; one for each revision.
            ->distinct()
            ->execute()
            ->fetchAll();
          // If we don't have a result, then we hit a dead end and
          // didn't find our parent entity.
          if (!isset($nid[0])) {
            break;
          }
          // If we found a node, then we're done. Grab the source_id result,
          // which will be the nid, and append it to our results list.
          if ($nid[0]->source_type == 'node') {
            $with_nid[$nid[0]->source_id] = $value;
            break;
          }
          // If we found a parent, but it wasn't the node, then
          // we need to loop again. The new target_type will be this
          // result's source_type, and the new target_id this result's
          // source_id. Set these, and loop again.
          $target_type = $nid[0]->source_type;
          $target_id = $nid[0]->source_id;
        }
      }
      $temp_results = $with_nid;
      break;

    case 'block_content':
      $with_nid = [];
      foreach ($temp_results as $id => $value) {
        $target_id = $value->revision_id;
        // Find the target_id, which will be the id of the parent entity.
        $nid = $db->select('node__layout_builder__layout')
          ->fields('node__layout_builder__layout', ['entity_id'])
          ->condition('layout_builder__layout_section', '%"block_revision_id";s:_:"' . $target_id . '";%', 'LIKE')
          ->execute()
          ->fetchAll();
        // If we don't have a result, then we hit a dead end and
        // didn't find our parent entity.
        if (!isset($nid[0])) {
          continue;
        }
        $with_nid[$nid[0]->entity_id] = $value;
      }
      $temp_results = $with_nid;
      break;

    case 'node':
      break;
  }
  return $temp_results;
}
