<?php

/**
 * @file
 * Primary module hooks for Sitenow Find Text module.
 *
 * @DCG
 * This file is no longer required in Drupal 8.
 * @see https://www.drupal.org/node/2217931
 */

/**
 * Grab field names and mappings for all text-based fields.
 *
 * @return array
 *   The field names => info mapping for all text-based fields.
 */
function get_all_text_fields() {
  $entity_field_manager = \Drupal::service('entity_field.manager');
  $fields = [];
  // Go through all our text-based field types,
  // get their field information, and bundle 'em.
  foreach (['string', 'string_long', 'text_long', 'text_with_summary', 'link'] as $type) {
    $new_fields = $entity_field_manager->getFieldMapByFieldType($type);
    foreach ($new_fields as $bundle => $bundle_fields) {
      $fields[$bundle] = isset($fields[$bundle]) ? array_merge($fields[$bundle], $bundle_fields) : $bundle_fields;
    }
  }
  return $fields;
}

/**
 * Search all fields for a needle.
 *
 * @param array $fields
 *   The field names and info to be searched.
 * @param string $needle
 *   The string for which to search.
 * @param bool $regexed
 *   Whether a regex condition should be used over base LIKE.
 *
 * @return array
 *   The search results.
 */
function search_fields(array $fields, string $needle, bool $regexed = FALSE) {
  $tables = [];
  $results = [];
  foreach ($fields as $entity_type_id => $field_map) {
    // Tables and columns may be constructed slightly differently
    // depending on the field type. Additionally, how they are
    // connected to a parent node may be different.
    switch ($entity_type_id) {
      case 'block_content':
      case 'paragraph':
        foreach ($field_map as $name => $info) {
          if (str_starts_with($name, 'field')) {
            $tables[$entity_type_id . '__' . $name] = [
              'values' => value_columns($name, $info['type']),
              'parent' => ['entity_id'],
              'type' => $entity_type_id,
              'field' => $name,
            ];
          }
        }
        break;

      case 'node':
        foreach ($field_map as $name => $info) {
          if (str_starts_with($name, 'field')) {
            $tables['node__' . $name] = [
              'values' => value_columns($name, $info['type']),
              'parent' => ['entity_id'],
              'type' => $entity_type_id,
              'field' => $name,
            ];
          }
          if ($name == 'title') {
            $tables['node_field_data'] = [
              'values' => ['title'],
              'parent' => ['nid'],
              'type' => $entity_type_id,
              'field' => $name,
            ];
          }
          if ($name == 'body') {
            $tables['node__body'] = [
              'values' => ['body_value'],
              'parent' => ['entity_id'],
              'type' => $entity_type_id,
              'field' => $name,
            ];
          }
        }
        break;
    }
  }
  $db = \Drupal::database();
  foreach ($tables as $table => $details) {
    $value_columns = $details['values'];
    $parent = $details['parent'];
    $query = $db->select($table)
      ->fields($table, array_merge($parent, $value_columns));
    foreach ($value_columns as $value_column) {
      if ($regexed) {
        $query->condition($table . '.' . $value_column, $needle, 'REGEXP');
      }
      else {
        // Note: We are not using $db->escapeLike($needle) here, at least currently,
        // to allow for the option of including wildcards in the provided string.
        // Otherwise we may need to include extra options, such as a non-escaped option,
        // or specifying word boundaries.
        $query->condition($table . '.' . $value_column, '%' . $needle . '%', 'LIKE');
      }
    }
    $temp_results = $query->execute()
      ->fetchAllKeyed(0);
    foreach ($temp_results as &$row) {
      $row = implode(': ', [$details['field'], $row]);
    }
    // If the table is of a node type, we're done. Otherwise, we need
    // to find the parent.
    if ($details['type'] != 'node') {
      $with_nid = [];
      // @todo Update this. Some entities have useful getParentEntity methods,
      //   but not all do. Inline blocks in particular make this tricky,
      //   but there is likely a better way than this.
      foreach ($temp_results as $target_id => $value) {
        $target_type = $details['type'];
        // We need to loop through it, as we may have nested entities,
        // like a paragraph under a block under a node.
        while (TRUE) {
          // Find the target_id, which will be the id of the parent entity.
          $nid = $db->select('entity_usage')
            ->fields('entity_usage', ['source_id', 'source_type'])
            ->condition('target_type', $target_type, '=')
            ->condition('target_id', $target_id, '=')
            // Currently we're not handling revisions, so we're likely to have
            // duplicate entries for the same node; one for each revision.
            ->distinct()
            ->execute()
            ->fetchAll();
          // If we don't have a result, then we hit a dead end and
          // didn't find our parent entity.
          if (!isset($nid[0])) {
            break;
          }
          // If we found a node, then we're done. Grab the source_id result,
          // which will be the nid, and append it to our results list.
          if ($nid[0]->source_type == 'node') {
            $with_nid[$nid[0]->source_id] = $value;
            break;
          }
          // If we found a parent, but it wasn't the node, then
          // we need to loop again. The new target_type will be this
          // result's source_type, and the new target_id this result's
          // source_id. Set these, and loop again.
          $target_type = $nid[0]->source_type;
          $target_id = $nid[0]->source_id;
        }
      }
      $temp_results = $with_nid;
    }

    foreach ($temp_results as $nid => $value) {
      $results[$nid][] = $value;
    }
  }
  return $results;
}

/**
 * Helper function to construct field value column names.
 *
 * @param string $name
 *   The field name.
 * @param string $type
 *   The type of field.
 *
 * @return string[]
 *   An array of value columns to retreive from the database table.
 */
function value_columns(string $name, string $type) {
  // @todo Check if we need to handle any of the other
  //   field types differently, like text_with_summary.
  if ($type == 'link') {
    return [
      $name . '_uri',
      $name . '_title',
    ];
  }
  if ($type == 'text_with_summary') {
    return [
      $name . '_value',
      $name . '_summary',
    ];
  }
  return [$name . '_value'];
}
