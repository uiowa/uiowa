<?php

/**
 * @file
 * The sitenow profile cannot contain a hook_install() implementation.
 * @see: https://www.drupal.org/project/drupal/issues/2982052
 */

use Drupal\block_content\BlockContentInterface;
use Drupal\Component\Utility\Html;
use Drupal\Core\Config\FileStorage;
use Drupal\Core\Database\Database;
use Drupal\Core\Entity\Display\EntityDisplayInterface;
use Drupal\Core\Entity\Sql\SqlContentEntityStorage;
use Drupal\Core\Entity\Sql\SqlContentEntityStorageException;
use Drupal\Core\Entity\Sql\SqlEntityStorageInterface;
use Drupal\field\Entity\FieldConfig;
use Drupal\field\Entity\FieldStorageConfig;
use Drupal\layout_builder\Section;
use Drupal\layout_builder\SectionComponent;
use Drupal\menu_link_content\Entity\MenuLinkContent;
use Drupal\node\Entity\Node;
use Drupal\paragraphs\Entity\Paragraph;
use Drupal\uiowa_core\Entity\Card;
use Drupal\uiowa_core\Entity\Event;

/**
 * Helper function to update all blocks of a type.
 */
function _update_all_blocks_by_plugin_id($block_plugin_ids, callable $process): void {
  if (!is_array($block_plugin_ids)) {
    $block_plugin_ids = [$block_plugin_ids];
  }
  $db = \Drupal::database();
  $block_storage = \Drupal::entityTypeManager()
    ->getStorage('block_content');

  $section_column = 'layout_builder__layout_section';
  $tables = [
    'node__layout_builder__layout',
    'node_revision__layout_builder__layout',
  ];
  $blocks = [];

  foreach ($tables as $table_name) {
    // Select DB records for our $table_name.
    $query = $db->select($table_name, 'n');

    // Match against any record that has a block matching our $block_plugin_id.
    $or_group = $query->orConditionGroup();
    foreach ($block_plugin_ids as $block_plugin_id) {
      $or_group = $or_group->condition($section_column, "%$block_plugin_id%", 'LIKE');
    }

    $query = $query->condition($or_group)
      ->fields('n', ['entity_id', 'revision_id', 'delta', $section_column]);

    $count = $query->countQuery()->execute()->fetchField();

    \Drupal::messenger()
      ->addMessage(t('Sections with blocks of @types records found in @table: @count', [
        '@types' => implode(', ', $block_plugin_ids),
        '@table' => $table_name,
        '@count' => $count,
      ]));

    $results = $query->execute();

    // Loop through the results.
    foreach ($results as $record) {
      // Unserialize the section field into it's class object.
      /** @var \Drupal\layout_builder\Section $section */
      $section = unserialize($record->{$section_column}, [
        'allowed_classes' => TRUE,
      ]);

      // Loop through the components in the section.
      /** @var \Drupal\layout_builder\SectionComponent $component */
      foreach ($section->getComponents() as &$component) {

        // Limit this to only the initial list of block plugins.
        if (!in_array($component->getPluginId(), $block_plugin_ids)) {
          continue;
        }

        $component_arr = $component->toArray();

        $block = NULL;

        if (isset($component_arr['configuration']['block_revision_id'])) {
          $revision_id = $component_arr['configuration']['block_revision_id'];
          if (empty($blocks[$revision_id])) {
            $blocks[$revision_id] = $block_storage->loadRevision($revision_id);
          }
          $block = $blocks[$revision_id];

          if (!$block instanceof BlockContentInterface) {
            continue;
          }
        }

        call_user_func_array($process, [&$component, $block]);
      }
      // Serialize section component and update section component db record.
      // Replace the old section with our newly created one.
      $db->update($table_name)
        ->condition('revision_id', $record->revision_id)
        ->condition('delta', $record->delta)
        ->fields([
          $section_column => serialize($section),
        ])
        ->execute();
    }
  }

  // Only continue with this section if we have a key_value_expire
  // table to work with.
  if ($db->schema()->tableExists('key_value_expire')) {
    // Check if we have a tempstore of this node.
    // Temp store is saved in the db in the key_value_expire,
    // And holds a serialized blob with the unsaved changes.
    // Might be a better method of accessing this through the Layout
    // Builder API and layoutTempstoreRepository, but have not found it yet.
    $query = $db->select('key_value_expire', 'kve');

    // Match against any record that has a block matching our $block_plugin_id.
    $or_group = $query->orConditionGroup();
    foreach ($block_plugin_ids as $block_plugin_id) {
      $or_group = $or_group->condition('value', "%$block_plugin_id%", 'LIKE');
    }

    $query = $query->condition('collection', 'tempstore.shared.layout_builder.section_storage.overrides', '=')
      ->condition($or_group)
      ->fields('kve');

    $count = $query->countQuery()->execute()->fetchField();

    \Drupal::messenger()
      ->addMessage(t('Tempstore records for sections with blocks of @types records found: @count', [
        '@types' => implode(', ', $block_plugin_ids),
        '@count' => $count,
      ]));

    $results = $query
      ->execute();

    foreach ($results as $record) {

      // Unserialize and replace the section in question with our updated one.
      $stored_data = unserialize($record->value, [
        'allowed_classes' => TRUE,
      ]);

      /** @var \Drupal\layout_builder\Plugin\SectionStorage\OverridesSectionStorage $section_storage */
      $section_storage = $stored_data->data['section_storage'];

      // Loop through sections in the storage.
      foreach ($section_storage->getSections() as &$section) {
        // Loop through the components in the section.
        foreach ($section->getComponents() as &$component) {

          // Limit this to only the initial list of block plugins.
          if (!in_array($component->getPluginId(), $block_plugin_ids)) {
            continue;
          }

          $component_arr = $component->toArray();

          if (isset($component_arr['configuration']['block_revision_id'])) {
            $block = $block_storage->loadRevision($component_arr['configuration']['block_revision_id']);
          }
          elseif (isset($component_arr['configuration']['block_serialized'])) {
            $block = unserialize($component_arr['configuration']['block_serialized'], [
              'allowed_classes' => TRUE,
            ]);
          }
          else {
            $block = NULL;
          }

          call_user_func_array($process, [&$component, $block]);
        }
      }
      $stored_data->data['section_storage'] = $section_storage;

      // Insert the updated tempstore.
      $db->update('key_value_expire')
        ->condition('name', $record->name, '=')
        ->condition('expire', $record->expire, '=')
        ->fields([
          'value' => serialize($stored_data),
        ])
        ->execute();
    }
  }
}

/**
 * Set list grid defaults for existing list blocks.
 */
function sitenow_update_9001() {
  $block_types = [
    'uiowa_aggregator',
    'uiowa_events',
    'uiowa_articles',
    'uiowa_people',
  ];
  foreach ($block_types as $block_type) {
    // Find NIDs for all nodes with at least one aggregator block.
    $query = \Drupal::entityQuery('node')
      ->accessCheck()
      ->condition('type', 'page')
      ->condition('layout_builder__layout', '%' . $block_type . '%', 'LIKE');

    $results = $query->execute();

    foreach ($results as $nid) {
      $node = \Drupal::entityTypeManager()->getStorage('node')->load($nid);
      /** @var \Drupal\layout_builder\Field\LayoutSectionItemList $layout */
      $layout = $node->get('layout_builder__layout');

      // Grab the sections. We'll set updated ones back in below.
      $layout_sections = $layout->getSections();

      /**
       * @var integer $delta_s
       * @var \Drupal\layout_builder\Section $section
       */
      foreach ($layout_sections as $delta_s => $section) {
        $section_is_updated = FALSE;

        // insertComponent() uses delta and region
        // which makes it more difficult to re-set components.
        // With an array and iterator we can set it directly.
        $section_arr = $section->toArray();
        $i = 0;

        /**
         * @var \Drupal\layout_builder\SectionComponent $component
         */
        foreach ($section->getComponents() as $component) {
          if ($component->getPluginId() === 'inline_block:' . $block_type) {
            // @phpstan-ignore-next-line
            $styles = $component->get('layout_builder_styles_style');
            $styles[] = 'list_format_list';
            $styles[] = 'block_grid_threecol_33_34_33';

            // @phpstan-ignore-next-line
            $component->set('layout_builder_styles_style', $styles);
            $section_arr['components'][$i] = $component->toArray();
            $section_is_updated = TRUE;
          }
          $i++;
        }

        if ($section_is_updated) {
          // Create a section from array, set, and save.
          $layout_sections[$delta_s] = Section::fromArray($section_arr);
          $node->set('layout_builder__layout', $layout_sections)
            ->save();
        }
      }
    }
  }
}

/**
 * Set new font-family theme setting.
 */
function sitenow_update_9002() {
  $config_factory = \Drupal::configFactory();
  $config = $config_factory->getEditable('uids_base.settings');
  $config->set('fonts.font-family', 'sans-serif');
  $config->save();
}

/**
 * Set menu links to expanded by default.
 */
function sitenow_update_9003(&$sandbox) {
  if (!isset($sandbox['total'])) {
    $query = \Drupal::entityQuery('menu_link_content')
      ->accessCheck()
      ->condition('expanded', 0, '=')
      ->execute();
    $sandbox['total'] = count($query);
    $sandbox['current'] = 0;
    $sandbox['query'] = $query;

    if (empty($sandbox['total'])) {
      $sandbox['#finished'] = 1;
      return;
    }
  }
  // Loop through menu links in batches.
  $per_batch = 100;
  $batch = array_slice($sandbox['query'], $sandbox['current'], $sandbox['current'] + $per_batch);
  if (empty($batch)) {
    $sandbox['#finished'] = 1;
    \Drupal::service('router.builder')->rebuild();
    return;
  }

  foreach ($batch as $mcid) {
    $menu_item = MenuLinkContent::load($mcid);
    $menu_item->expanded = 1;
    $menu_item->save();
    $sandbox['current']++;
  }

  \Drupal::messenger()
    ->addMessage($sandbox['current'] . ' menu items processed.');

  if ($sandbox['current'] >= $sandbox['total']) {
    $sandbox['#finished'] = 1;
  }
  else {
    $sandbox['#finished'] = ($sandbox['current'] / $sandbox['total']);
  }
}

/**
 * Update menu block instance settings to show 1 level of menu.
 */
function sitenow_update_9004(&$sandbox) {
  $connection = Database::getConnection();

  // We need to adjust the records for the current node
  // version and previous revisions.
  foreach ([
    'node_revision__layout_builder__layout',
    'node__layout_builder__layout',
  ] as $table_name) {
    $query = $connection->select($table_name, 'n');
    $orGroup = $query->orConditionGroup()
      ->condition('layout_builder__layout_section', '%s:5:"depth";i:0;%', 'LIKE')
      ->condition('layout_builder__layout_section', '%s:5:"depth";s:1:"0"%', 'LIKE');

    $query->fields('n', ['entity_id'])
      ->condition($orGroup);
    $count = $query->countQuery()->execute()->fetchField();

    \Drupal::messenger()
      ->addMessage($table_name . ' records found (before): ' . $count);

    // For reasons I can't quite understand,
    // the depth config in the menu block settings
    // get serialized as an integer in some cases
    // and as a string in others. We have to handle
    // both.
    // Handle integer case.
    $connection->update($table_name)
      ->condition('layout_builder__layout_section', '%menu_block:main%', 'LIKE')
      ->expression('layout_builder__layout_section', 'REPLACE(layout_builder__layout_section, :old, :new)', [
        ':old' => 's:5:"depth";i:0;',
        ':new' => 's:5:"depth";i:1;',
      ])
      ->execute();
    // Handle string case.
    $connection->update($table_name)
      ->condition('layout_builder__layout_section', '%menu_block:main%', 'LIKE')
      ->expression('layout_builder__layout_section', 'REPLACE(layout_builder__layout_section, :old, :new)', [
        ':old' => 's:5:"depth";s:1:"0"',
        ':new' => 's:5:"depth";s:1:"1"',
      ])
      ->execute();

    $count = $query->countQuery()->execute()->fetchField();

    \Drupal::messenger()
      ->addMessage($table_name . ' records found (after): ' . $count);
  }
}

/**
 * Enable grad_person_extended split.
 *
 * In cases where the person_extended split was being used,
 * enable the grad_person_extended split to take its place.
 */
function sitenow_update_9005() {

  /** @var \Drupal\Core\Plugin\DefaultPluginManager $filters */
  $filters = \Drupal::service('plugin.manager.config_filter')->getDefinitions();
  $split = 'config_split:person_extended';

  // If person_extended split isn't registered or
  // isn't active, return early.
  if (!isset($filters[$split]) || !$filters[$split]['status']) {
    return t('person_extended split is not active, so no update to run.');
  }

  $config_path = DRUPAL_ROOT . '/../config/default';
  $source = new FileStorage($config_path);

  // Create field storage for new person type status field.
  \Drupal::entityTypeManager()
    ->getStorage('field_storage_config')
    ->create($source->read('field.storage.node.field_person_type_status'))
    ->save();

  // Create field instance for 'field_person_type_status'.
  \Drupal::entityTypeManager()->getStorage('field_config')
    ->create($source->read('field.field.node.person.field_person_type_status'))
    ->save();

  // The following config is needed for the next update.
  $config_names = [
    'config_ignore.settings',
    'config_split.config_split.grad_person_extended',
  ];
  $config_storage = \Drupal::service('config.storage');
  foreach ($config_names as $config_name) {
    $config_storage->write($config_name, $source->read($config_name));
  }

  // Enable the 'person_extended' split.
  $config_factory = \Drupal::configFactory();
  $config = $config_factory->getEditable('config_split.config_split.grad_person_extended');
  $config->set('status', TRUE);
  $config->save(TRUE);
}

/**
 * Update sites using the person_extended to reflect changes to that split.
 */
function sitenow_update_9006(&$sandbox) {
  /** @var \Drupal\Core\Plugin\DefaultPluginManager $filters */
  $filters = \Drupal::service('plugin.manager.config_filter')->getDefinitions();
  $split = 'config_split:person_extended';

  // If person_extended split isn't registered or
  // isn't active, return early.
  if (!isset($filters[$split]) || !$filters[$split]['status']) {
    return t('person_extended split is not active, so no update to run.');
  }

  // Process all nodes that have a filled person.
  if (!isset($sandbox['total'])) {
    $query = \Drupal::entityQuery('node')
      ->accessCheck(TRUE)
      ->condition('type', 'person')
      ->execute();

    $sandbox['total'] = count($query);
    $sandbox['current'] = 0;
    $sandbox['query'] = $query;

    if (empty($sandbox['total'])) {
      $sandbox['#finished'] = 1;
      return;
    }
  }
  // Loop through the same nodes in batches.
  $nodes_per_batch = 25;
  $batch = array_slice($sandbox['query'], $sandbox['current'], $sandbox['current'] + $nodes_per_batch);
  if (empty($batch)) {
    $sandbox['#finished'] = 1;
    return;
  }

  foreach ($batch as $nid) {
    // Load the node, set a flag for whether we need to save the node.
    $node = Node::load($nid);
    // Unset any gremlins.
    $node->set('field_person_contact_information', NULL);
    $save_node = FALSE;
    $field_fragments = [
      'room',
      'building',
      'phone',
    ];
    foreach ([
      'lab',
      'office',
    ] as $location_type) {
      $location = [];
      foreach ($field_fragments as $fragment_name) {
        $field_name = "field_person_{$location_type}_{$fragment_name}";
        if ($node->hasField($field_name) && $node->{$field_name}->value) {
          $location[$fragment_name] = $node->{$field_name}->value;
          // Remove field instances from node.
          $node->set($field_name, NULL);
          // Now we need to save the node.
          $save_node = TRUE;
        }
      }

      if (!empty($location)) {
        // Create a Contact Info paragraph instance.
        // and populate with location info.
        $contact_info = Paragraph::create([
          'type' => 'uiowa_contact',
          'field_uiowa_contact_label' => [
            'value' => ucfirst($location_type),
          ],
        ]);

        // If a phone number is present, pop it off the array
        // and add it.
        if (isset($location['phone'])) {
          $contact_info->field_uiowa_contact_phone = array_pop($location);
        }

        // Create the address_line1 string.
        $address = implode(' ', $location);

        // If there is an address_line1, build the address object.
        if ($address !== '') {
          $field_uiowa_contact_address = [
            'country_code' => 'US',
            'address_line1' => $address,
          ];
          $contact_info->set('field_uiowa_contact_address', $field_uiowa_contact_address);
        }
        // Save the contact info.
        $contact_info->save();

        // Attach the contact info to the node.
        $node->field_person_contact_information[] = [
          'target_id' => $contact_info->id(),
          'target_revision_id' => $contact_info->getRevisionId(),
        ];
        $save_node = TRUE;
      }
    }

    // Check if we have the current student field and
    // the person types field.
    if ($node->hasField('field_pt_student_current') && $node->hasField('field_person_types')) {
      // If the person type includes 'student' and
      // current student is FALSE, set the person type status.
      $existing_types = array_column($node->field_person_types->getValue(), 'target_id');
      if (in_array('student', $existing_types) && !$node->field_pt_student_current->value) {
        $node->field_person_type_status->setValue(['value' => 'student']);
        $save_node = TRUE;
      }
    }

    // Save node if there were changes.
    if ($save_node) {
      // Set revision message and save.
      $node->setRevisionLogMessage('Automated save.');
      $node->save();
    }
    $sandbox['current']++;
  }

  \Drupal::messenger()
    ->addMessage($sandbox['current'] . ' nodes processed.');

  if ($sandbox['current'] >= $sandbox['total']) {
    $sandbox['#finished'] = 1;
  }
  else {
    $sandbox['#finished'] = ($sandbox['current'] / $sandbox['total']);
  }
}

/**
 * Update button classes.
 */
function sitenow_update_9007() {
  // Removed as part of https://github.com/uiowa/uiowa/pull/5324
}

/**
 * Fix table classes that were inadvertently broken.
 */
function sitenow_update_9008() {
  // Removed as part of https://github.com/uiowa/uiowa/pull/5324
}

/**
 * Helper function to convert an existing people block to a list view block.
 */
function _convert_people_block_component(SectionComponent &$component, BlockContentInterface $block) {
  // @phpstan-ignore-next-line
  $styles = $component->get('layout_builder_styles_style');

  // Default LB styles for new block.
  $new_styles = [
    'card_media_position_right',
    'media_format_circle',
    'content_alignment_left',
    'card_image_small',
    'list_format_list',
    'block_grid_threecol_33_34_33',
  ];

  if (is_array($styles)) {

    $style_update_map = [
      'block_hide_descriptions' => 'delete',
      'block_hide_details' => 'delete',
      'block_hide_images' => 'delete',
      'block_grid_twocol_50_50' => 'block_grid_threecol_33_34_33',
      'list_format_grid' => 'list_format_list',
    ];

    foreach ($styles as $style) {
      if (isset($style_update_map[$style])) {
        if ($style_update_map[$style] === 'delete') {
          continue;
        }
        if ($key = array_search($style_update_map[$style], $new_styles)) {
          $new_styles[$key] = $style;
        }
      }
    }

    $new_styles = array_unique($new_styles);
  }

  // Build out the new view block configuration.
  $config = [
    'id' => 'views_block:people_list_block-list_card',
    'label' => NULL,
    'provider' => 'views',
    'label_display' => NULL,
    'views_label' => '',
    'items_per_page' => $block->field_collection_results->value ?: 'none',
    'headline' => $block->get('field_uiowa_headline')
      ->getValue()[0],
    'pager' => $block->field_collection_pager->value ? 'full' : 'some',
    'pager_offset' => 0,
    'use_more' => $block->field_collection_more->value,
    'use_more_link_url' => $block->field_collection_more_path->value,
    'sort' => [
      'sticky' => [
        'order' => 'DESC',
        'weight' => 0,
      ],
      'field_person_last_name_value' => [
        'order' => 'ASC',
        'weight' => 0,
      ],
      'field_person_first_name_value' => [
        'order' => 'ASC',
        'weight' => 0,
      ],
    ],
    'exposed_filter_values' => [
      'field_tags_target_id' => [],
    ],
    'layout_builder_styles' => $new_styles,
    'context_mapping' => [],
  ];

  // Process tags.
  if (isset($block->get('field_collection_reference')
    ->getValue()[0])) {
    foreach ($block->get('field_collection_reference')
      ->getValue()[0] as $target) {
      $config['exposed_filter_values']['field_tags_target_id'][] = ['target_id' => $target];
    }
  }

  $fields = [
    'field_person_credential',
    'title',
    'field_teaser',
    'field_person_email',
    'field_image',
    'field_person_phone',
    'field_person_position',
  ];

  // Process field visibility settings.
  foreach ($fields as $field) {
    $hide = 0;
    if (isset($styles)) {
      switch ($field) {
        case 'field_image':
          if (in_array('block_hide_images', $styles)) {
            $hide = 1;
          }
          break;

        case 'field_teaser':
          if (in_array('block_hide_descriptions', $styles)) {
            $hide = 1;
          }
          break;

        case 'field_person_email':
        case 'field_person_phone':
          if (in_array('block_hide_details', $styles)) {
            $hide = 1;
          }
          break;
      }
    }

    $config['fields'][$field]['hide'] = $hide;
  }

  // Process sorting defaults.
  $current_sort = $block->field_collection_sort->value;
  if ($current_sort === 'block_people_sfl') {
    $last_name_sort = $config['sort']['field_person_last_name_value'];
    unset($config['sort']['field_person_last_name_value']);
    $config['sort']['field_person_last_name_value'] = $last_name_sort;
  }

  // Repurpose the existing component and set new styles.
  $component->setConfiguration($config);

  // @phpstan-ignore-next-line
  $component->set('layout_builder_styles_style', $new_styles);
}

/**
 * Update all LB people blocks to views block.
 */
function sitenow_update_9009() {
  $db = \Drupal::database();
  $block_storage = \Drupal::entityTypeManager()
    ->getStorage('block_content');

  $section_column = 'layout_builder__layout_section';
  $tables = [
    'node__layout_builder__layout',
    'node_revision__layout_builder__layout',
  ];

  // Collect all the block instances so we can delete them at the end.
  $blocks = [];

  foreach ($tables as $table_name) {
    // Select instances where the section contains a uiowa_people block.
    $query = $db->select($table_name, 'n')
      ->condition($section_column, '%uiowa_people%', 'LIKE')
      ->fields('n', ['entity_id', 'revision_id', 'delta', $section_column]);

    $count = $query->countQuery()->execute()->fetchField();

    \Drupal::messenger()
      ->addMessage('People block records found: ' . $count);

    $results = $query->execute();

    // Loop through the results.
    foreach ($results as $record) {

      // Unserialize the section field into it's class object. Allowed classes
      // were set to FALSE for PHPCS after the update had already run.
      /** @var \Drupal\layout_builder\Section $section */
      $section = unserialize($record->layout_builder__layout_section, [
        'allowed_classes' => FALSE,
      ]);

      // Loop through the components in the section.
      foreach ($section->getComponents() as &$component) {

        // Limit this to only the uiowa_people block component.
        if ($component->getPluginId() !== 'inline_block:uiowa_people') {
          continue;
        }

        $component_arr = $component->toArray();
        $revision_id = $component_arr['configuration']['block_revision_id'];

        if (!$revision_id) {
          continue;
        }

        if (empty($blocks[$revision_id])) {
          $blocks[$revision_id] = $block_storage->loadRevision($revision_id);
        }

        if (is_null($blocks[$revision_id])) {
          continue;
        }

        _convert_people_block_component($component, $blocks[$revision_id]);
      }

      // Replace the old section with our newly created one.
      $db->update($table_name)
        ->condition('revision_id', $record->revision_id)
        ->condition('delta', $record->delta)
        ->fields([
          $section_column => serialize($section),
        ])
        ->execute();
    }
  }

  // Only continue with this section if we have a key_value_expire
  // table to work with.
  if ($db->schema()->tableExists('key_value_expire')) {
    // Check if we have a tempstore of this node.
    // Temp store is saved in the db in the key_value_expire,
    // And holds a serialized blob with the unsaved changes.
    // Might be a better method of accessing this through the Layout Builder API
    // and layoutTempstoreRepository, but have not found it yet.
    $query = $db->select('key_value_expire', 'kve')
      ->fields('kve', ['name', 'value', 'expire'])
      ->condition('value', '%uiowa_people%', 'LIKE');

    $count = $query->countQuery()->execute()->fetchField();

    \Drupal::messenger()
      ->addMessage('Tempstore records found: ' . $count);

    $results = $query
      ->execute();

    foreach ($results as $record) {
      // Unserialize and replace the section in question with our updated one.
      // Allowed classes were set to FALSE for PHPCS after the update
      // had already run.
      $stored_data = unserialize($record->value, [
        'allowed_classes' => FALSE,
      ]);

      /** @var \Drupal\layout_builder\Plugin\SectionStorage\OverridesSectionStorage $section_storage */
      $section_storage = $stored_data->data['section_storage'];

      // Loop through sections in the storage.
      foreach ($section_storage->getSections() as &$section) {
        // Loop through the components in the section.
        foreach ($section->getComponents() as &$component) {

          // Limit this to only the uiowa_people block component.
          if ($component->getPluginId() !== 'inline_block:uiowa_people') {
            continue;
          }

          $component_arr = $component->toArray();
          $revision_id = $component_arr['configuration']['block_revision_id'];

          if ($revision_id) {
            if (empty($blocks[$revision_id])) {
              $blocks[$revision_id] = $block_storage->loadRevision($revision_id);
            }
            $block = $blocks[$revision_id];
          }
          else {
            // Allowed classes were set to FALSE for PHPCS after the
            // update had already run.
            $block = unserialize($component_arr['configuration']['block_serialized'], [
              'allowed_classes' => FALSE,
            ]);
          }

          if (!$block instanceof BlockContentInterface) {
            continue;
          }

          _convert_people_block_component($component, $block);
        }
      }
      $stored_data->data['section_storage'] = $section_storage;

      // Insert the updated tempstore.
      $db->update('key_value_expire')
        ->condition('name', $record->name, '=')
        ->condition('expire', $record->expire, '=')
        ->fields([
          'value' => serialize($stored_data),
        ])
        ->execute();
    }
  }
  // Delete all the blocks.
  foreach ($blocks as $block) {
    if (!is_null($block)) {
      $block->delete();
    }
  }
}

/**
 * Set - None - section container options to Normal.
 */
function sitenow_update_9010() {
  $connection = Database::getConnection();

  // We need to adjust the records for the current node
  // version and previous revisions.
  foreach ([
    'node_revision__layout_builder__layout',
    'node__layout_builder__layout',
  ] as $table_name) {
    // If the section has a "section_margin_*" style, we can ignore it.
    // It already has a container style selected.
    $query = $connection->select($table_name, 'n')
      ->fields('n', ['entity_id', 'delta', 'layout_builder__layout_section'])
      ->condition('layout_builder__layout_section', '%section_margin_%', 'NOT LIKE');

    $records = $query->execute()->fetchAll();

    \Drupal::messenger()
      ->addMessage($table_name . ' records found (before): ' . count($records));

    // We'll want to collect NIDs for pages we're updating
    // to check against the temp store later.
    $nids = [];

    foreach ($records as $record) {
      // Add the entity ID to our update list.
      $nids[$record->entity_id] = $record->entity_id;

      // Unserialize the record and extract the layout settings. Allowed classes
      // were set to FALSE for PHPCS after the update had already run.
      $stored_data = unserialize($record->layout_builder__layout_section, [
        'allowed_classes' => FALSE,
      ]);

      $layout_settings = $stored_data->getLayoutSettings();
      // Add in the 'Normal' container style.
      // We only pulled records that didn't have a container style,
      // so this can simply be appended.
      $layout_settings['layout_builder_styles_style']['section_margin_fixed_width_container'] = 'section_margin_fixed_width_container';
      $stored_data->setLayoutSettings($layout_settings);

      // Insert the updated settings back into the DB.
      $connection->update($table_name)
        ->condition('entity_id', $record->entity_id, '=')
        ->condition('delta', $record->delta, '=')
        ->fields([
          'layout_builder__layout_section' => serialize($stored_data),
        ])
        ->execute();
    }
    $query = $connection->select($table_name, 'n')
      ->fields('n', ['entity_id', 'delta', 'layout_builder__layout_section'])
      ->condition('layout_builder__layout_section', '%section_margin_%', 'NOT LIKE');

    $count = $query->countQuery()->execute()->fetchField();

    \Drupal::messenger()
      ->addMessage($table_name . ' records found (after): ' . $count);
  }

  // If the key_value_expire table doesn't exist, we're done.
  if (!$connection->schema()->tableExists('key_value_expire')) {
    return;
  }

  // Update sections w/no section_margin_ that might be in the temp store.
  $query = $connection->select('key_value_expire', 'kve')
    ->fields('kve', ['name', 'value', 'expire'])
    ->condition('collection', 'tempstore.shared.layout_builder.section_storage.overrides', '=');
  $records = $query->execute()->fetchAll();

  // Create a helper for regex later.
  $nid_matcher = '(' . implode('|', array_keys($nids)) . ')';

  foreach ($records as $record) {
    $replaced = FALSE;

    // If it's not in our list of updated nodes, skip it.
    if (!preg_match("@node\." . $nid_matcher . "\.default\.en@", $record->name)) {
      continue;
    }
    // Unserialize and replace the section in question with our updated one.
    // Allowed classes were set to FALSE for PHPCS after the update had
    // already run.
    $stored_data = unserialize($record->value, [
      'allowed_classes' => FALSE,
    ]);

    /** @var \Drupal\layout_builder\Plugin\SectionStorage\OverridesSectionStorage $section_storage */
    $section_storage = $stored_data->data['section_storage'];
    // Loop through sections in the storage.
    foreach ($section_storage->getSections() as &$section) {
      $layout_settings = $section->getLayoutSettings();
      // Check if we have any section_margin_ layout builder styles,
      // and skip if we do.
      if (preg_match('@section_margin_@', implode(',', array_keys($layout_settings['layout_builder_styles_style'])))) {
        continue;
      }
      $layout_settings['layout_builder_styles_style']['section_margin_fixed_width_container'] = 'section_margin_fixed_width_container';
      $section->setLayoutSettings($layout_settings);
      $replaced = TRUE;
    }
    // If we didn't update any sections,
    // let's continue without touching the DB.
    if (!$replaced) {
      continue;
    }

    $stored_data->data['section_storage'] = $section_storage;

    // Insert the updated tempstore.
    $connection->update('key_value_expire')
      ->condition('name', $record->name, '=')
      ->condition('expire', $record->expire, '=')
      ->fields([
        'value' => serialize($stored_data),
      ])
      ->execute();
  }
}

/**
 * Redo 9009.
 */
function sitenow_update_9011() {
  sitenow_update_9009();

  // Delete remaining orphans?
  $result = \Drupal::entityQuery('block_content')
    ->accessCheck(TRUE)
    ->condition('type', 'uiowa_people')
    ->execute();
  if ($result) {
    $storage_handler = \Drupal::entityTypeManager()->getStorage('block_content');
    $entities = $storage_handler->loadMultiple($result);
    $storage_handler->delete($entities);
  }
}

/**
 * Update existing uiowa_banner blocks to have a default headline_size style.
 */
function sitenow_update_9012() {
  $db = \Drupal::database();

  $section_column = 'layout_builder__layout_section';
  $tables = [
    'node__layout_builder__layout',
    'node_revision__layout_builder__layout',
  ];

  foreach ($tables as $table_name) {
    // Select instances where the section contains a uiowa_banner block.
    $query = $db->select($table_name, 'n')
      ->condition($section_column, '%uiowa_banner%', 'LIKE')
      ->fields('n', ['entity_id', 'revision_id', 'delta', $section_column]);

    $count = $query->countQuery()->execute()->fetchField();

    \Drupal::messenger()
      ->addMessage('Banner block records found: ' . $count);

    $results = $query->execute();

    // Loop through the results.
    foreach ($results as $record) {
      // Unserialize the section field into it's class object. Allowed classes
      // were set to FALSE for PHPCS after the update had already run.
      /** @var \Drupal\layout_builder\Section $section */
      $section = unserialize($record->layout_builder__layout_section, [
        'allowed_classes' => FALSE,
      ]);

      // Loop through the components in the section.
      foreach ($section->getComponents() as &$component) {

        // Limit this to only the uiowa_people block component.
        if ($component->getPluginId() !== 'inline_block:uiowa_banner') {
          continue;
        }

        // Pull the layout builder styles from the component.
        // @phpstan-ignore-next-line
        $styles = $component->get('layout_builder_styles_style');

        // Add key for new layout builder style.
        $styles[] = 'headline_large';

        // Set the layout builder styles on the component.
        // @phpstan-ignore-next-line
        $component->set('layout_builder_styles_style', $styles);

      }
      // Serialize section component and update section component db record.
      // Replace the old section with our newly created one.
      $db->update($table_name)
        ->condition('revision_id', $record->revision_id)
        ->condition('delta', $record->delta)
        ->fields([
          $section_column => serialize($section),
        ])
        ->execute();
    }

    // Only continue with this section if we have a key_value_expire
    // table to work with.
    if ($db->schema()->tableExists('key_value_expire')) {
      // Check if we have a tempstore of this node.
      // Temp store is saved in the db in the key_value_expire,
      // And holds a serialized blob with the unsaved changes.
      // Might be a better method of accessing this through the Layout
      // Builder API and layoutTempstoreRepository, but have not found it yet.
      $query = $db->select('key_value_expire', 'kve')
        ->fields('kve', ['name', 'value', 'expire'])
        ->condition('collection', 'tempstore.shared.layout_builder.section_storage.overrides', '=')
        ->condition('value', '%uiowa_banner%', 'LIKE');

      $count = $query->countQuery()->execute()->fetchField();

      \Drupal::messenger()
        ->addMessage('Tempstore records found: ' . $count);

      $results = $query
        ->execute();

      foreach ($results as $record) {
        // Unserialize and replace the section in question with our updated one.
        // Allowed classes were set to FALSE for PHPCS after the update had
        // already run.
        $stored_data = unserialize($record->value, [
          'allowed_classes' => FALSE,
        ]);

        /** @var \Drupal\layout_builder\Plugin\SectionStorage\OverridesSectionStorage $section_storage */
        $section_storage = $stored_data->data['section_storage'];

        // Loop through sections in the storage.
        foreach ($section_storage->getSections() as &$section) {
          // Loop through the components in the section.
          foreach ($section->getComponents() as &$component) {

            // Limit this to only the uiowa_banner block component.
            if ($component->getPluginId() !== 'inline_block:uiowa_banner') {
              continue;
            }

            // Pull the layout builder styles from the component.
            // @phpstan-ignore-next-line
            $styles = $component->get('layout_builder_styles_style');

            // Add key for new layout builder style.
            $styles[] = 'headline_large';

            // Set the layout builder styles on the component.
            // @phpstan-ignore-next-line
            $component->set('layout_builder_styles_style', $styles);
          }
        }
        $stored_data->data['section_storage'] = $section_storage;

        // Insert the updated tempstore.
        $db->update('key_value_expire')
          ->condition('name', $record->name, '=')
          ->condition('expire', $record->expire, '=')
          ->fields([
            'value' => serialize($stored_data),
          ])
          ->execute();
      }
    }
  }
}

/**
 * Rebuilding permissions after https://github.com/uiowa/uiowa/pull/3776.
 */
function sitenow_update_9013() {
  // Batch it.
  node_access_rebuild(TRUE);
}

/**
 * Redo 9009.
 */
function sitenow_update_9014() {
  sitenow_update_9009();

  // Delete remaining orphans?
  $result = \Drupal::entityQuery('block_content')
    ->accessCheck(TRUE)
    ->condition('type', 'uiowa_people')
    ->execute();

  \Drupal::messenger()
    ->addMessage('Orphaned records found: ' . count($result));

  if ($result) {
    $storage_handler = \Drupal::entityTypeManager()->getStorage('block_content');
    $entities = $storage_handler->loadMultiple($result);
    $storage_handler->delete($entities);
  }
}

/**
 * Clear cache for lazy update and update engineering migrated files metadata.
 */
function sitenow_update_9015() {
  // Removed as part of https://github.com/uiowa/uiowa/pull/5324
}

/**
 * Uninstall node_view_permissions, import role configs, rebuild permissions.
 */
function sitenow_update_9016() {
  // Uninstall node_view_permissions module.
  \Drupal::service('module_installer')->uninstall(['node_view_permissions']);

  // Import role configs.
  $config_storage = \Drupal::service('config.storage');
  $config_path = DRUPAL_ROOT . '/../config/default';
  $source = new FileStorage($config_path);
  $config_names = $source->listAll('user.role');

  foreach ($config_names as $config_name) {
    $config = $source->read($config_name);

    if ($config) {
      $config_storage->write($config_name, $config);
    }
  }

  // Loop through filters to find all the config splits that are
  // in use.
  /** @var \Drupal\Core\Plugin\DefaultPluginManager $filters */
  $filters = \Drupal::service('plugin.manager.config_filter')->getDefinitions();

  foreach ($filters as $filter) {
    if ($filter['status'] && isset($filter['config_name'])) {
      $config_split = $source->read($filter['config_name']);
      if (isset($config_split['folder'])) {
        $source = new FileStorage($config_split['folder']);
        // Loop through user.role.* config in the split folder and import them.
        $config_names = $source->listAll('user.role');
        foreach ($config_names as $config_name) {
          $config_storage->write($config_name, $source->read($config_name));
        }
      }
    }
  }

  // Rebuild node permissions.
  node_access_rebuild(TRUE);
}

/**
 * Activate new site splits prior to import so config remains constant.
 */
function sitenow_update_9017() {
  $splits = [
    'sites/admissions.uiowa.edu' => 'admissions.uiowa.edu',
    'sites/brand.uiowa.edu' => 'brand.uiowa.edu',
    'sites/coronavirus.uiowa.edu' => 'coronavirus.uiowa.edu',
    'sites/genetics.grad.uiowa.edu' => 'genetics.grad.uiowa.edu',
    'sites/grad.uiowa.edu' => 'grad.uiowa.edu',
    'sites/hr.uiowa.edu' => 'hr.uiowa.edu',
    'sites/icsa.uiowa.edu' => 'icsa.uiowa.edu',
    'sites/ighn.international.uiowa.edu' => 'ighn.international.uiowa.edu',
    'sites/immuno.grad.uiowa.edu' => 'immuno.grad.uiowa.edu',
    'sites/iowasuperfund.uiowa.edu' => 'iowasuperfund.uiowa.edu',
    'sites/pharmacy.uiowa.edu' => 'pharmacy.uiowa.edu',
    'sites/policy.clas.uiowa.edu' => 'policy.clas.uiowa.edu',
    'sites/presidentialsearch.uiowa.edu' => 'presidentialsearch.uiowa.edu',
    'sites/sitenow.uiowa.edu' => 'sitenow.uiowa.edu',
    'sites/sppa.uiowa.edu' => 'sppa.uiowa.edu',
    'sites/tippie.uiowa.edu' => 'tippie.uiowa.edu',
    'sites/transportation.uiowa.edu' => 'transportation.uiowa.edu',
    'sites/uiowa.edu' => 'uiowa.edu',
  ];

  $path = \Drupal::getContainer()->getParameter('site.path');

  if (isset($splits[$path])) {
    $source = new FileStorage('../config/sites/' . $splits[$path]);
    $config_storage = \Drupal::service('config.storage');
    $config_storage->write('config_split.config_split.site', $source->read('config_split.config_split.site'));
  }
}

/**
 * Add allowed replicate content entities.
 */
function sitenow_update_9020() {
  /** @var \Drupal\Core\Plugin\DefaultPluginManager $filters */
  $filters = \Drupal::service('plugin.manager.config_filter')->getDefinitions();
  $sitenow_v2_split = 'config_split:sitenow_v2';

  $config_factory = \Drupal::configFactory();
  $config = $config_factory->getEditable('uiowa_core.settings');

  // This site has the 'sitenow_v2' split in config,
  // and it is enabled.
  if (isset($filters[$sitenow_v2_split]) && $filters[$sitenow_v2_split]['status']) {
    // Don't allow for any content types to be replicated.
    $config
      ->set('uiowa_core.replicate_allowed', [])
      ->save();
  }
  else {
    // If it's not v2, then allow page and article.
    $config
      ->set('uiowa_core.replicate_allowed', ['page', 'article'])
      ->save();
  }
}

/**
 * Shut down replicate for now.
 */
function sitenow_update_9021() {
  $config_factory = \Drupal::configFactory();
  $config = $config_factory->getEditable('uiowa_core.settings');
  $config
    ->set('uiowa_core.replicate_allowed', [])
    ->save();
}

/**
 * Re-activate replicate functionality for v3 sites.
 */
function sitenow_update_9022() {
  sitenow_update_9020();
}

/**
 * Run again for any sites that were installed without this config.
 */
function sitenow_update_9023() {
  sitenow_update_9020();
}

/**
 * Remove headline content from footer block before setting perms.
 */
function sitenow_update_9024() {
  // Removed as part of https://github.com/uiowa/uiowa/pull/5324
}

/**
 * Convert uiowa_articles to article_list_block.
 */
function sitenow_update_9025() {
  _update_all_blocks_by_plugin_id('inline_block:uiowa_articles', function (&$component, $block) {
    $styles = $component->get('layout_builder_styles_style');

    // Default LB styles for new block.
    $new_styles = [
      'card_media_position_right',
      'media_format_widescreen',
      'content_alignment_left',
      'card_image_medium',
      'list_format_list',
      'block_grid_threecol_33_34_33',
    ];

    if (is_array($styles)) {

      $style_update_map = [
        'block_hide_descriptions' => 'delete',
        'block_hide_details' => 'delete',
        'block_hide_images' => 'delete',
        'block_grid_twocol_50_50' => 'block_grid_threecol_33_34_33',
        'list_format_grid' => 'list_format_list',
      ];

      foreach ($styles as $style) {
        if (isset($style_update_map[$style])) {
          if ($style_update_map[$style] === 'delete') {
            continue;
          }
          if ($key = array_search($style_update_map[$style], $new_styles)) {
            $new_styles[$key] = $style;
          }
        }
      }

      $new_styles = array_unique($new_styles);
    }

    // Build out the new view block configuration.
    $config = [
      'id' => 'views_block:article_list_block-list_article',
      'label' => NULL,
      'provider' => 'views',
      'label_display' => NULL,
      'views_label' => '',
      'items_per_page' => $block->field_collection_results->value ?: 50,
      'headline' => $block->get('field_uiowa_headline')
        ->getValue()[0],
      'pager' => $block->field_collection_pager->value ? 'full' : 'some',
      'pager_offset' => 0,
      'use_more' => $block->field_collection_more->value,
      'use_more_link_url' => $block->field_collection_more_path->uri,
      'sort' => [
        'sticky' => [
          'order' => 'DESC',
          'weight' => 0,
        ],
        'created' => [
          'order' => 'DESC',
          'weight' => 0,
        ],
      ],
      'exposed_filter_values' => [
        'field_tags_target_id' => [],
      ],
      'layout_builder_styles' => $new_styles,
      'context_mapping' => [],
    ];

    // Process tags.
    if (isset($block->get('field_collection_reference')
      ->getValue()[0])) {
      foreach ($block->get('field_collection_reference')
        ->getValue()[0] as $target) {
        $config['exposed_filter_values']['field_tags_target_id'][] = ['target_id' => $target];
      }
    }

    $fields = [
      'field_image',
      'created',
      'field_article_author',
      'field_article_source_org',
      'field_article_source_link',
      'field_teaser',
    ];

    // Process field visibility settings.
    foreach ($fields as $field) {
      $hide = 0;
      if (isset($styles)) {
        switch ($field) {
          case 'field_image':
            if (in_array('block_hide_images', $styles)) {
              $hide = 1;
            }
            break;

          case 'field_teaser':
            if (in_array('block_hide_descriptions', $styles)) {
              $hide = 1;
            }
            break;

          case 'field_article_author':
          case 'field_article_source_org':
            if (in_array('block_hide_details', $styles)) {
              $hide = 1;
            }
            break;

          // Hide by default due to functionality changes.
          case 'field_article_source_link':
            $hide = 1;
            break;
        }
      }

      $config['fields'][$field]['hide'] = $hide;
    }

    // Repurpose the existing component and set new styles.
    $component->setConfiguration($config);
    $component->set('layout_builder_styles_style', $new_styles);
  });

  // Delete uiowa_articles orphans.
  $result = \Drupal::entityQuery('block_content')
    ->accessCheck(TRUE)
    ->condition('type', 'uiowa_articles')
    ->execute();
  if ($result) {
    $storage_handler = \Drupal::entityTypeManager()->getStorage('block_content');
    $entities = $storage_handler->loadMultiple($result);
    $storage_handler->delete($entities);
  }
}

/**
 * Update views list blocks with use_more_text option.
 */
function sitenow_update_9026() {
  foreach ([
    'views_block:people_list_block-list_card',
    'views_block:article_list_block-list_article',
  ] as $block_plugin_id) {
    _update_all_blocks_by_plugin_id($block_plugin_id, function (&$component, $block) {
      $config = $component->get('configuration');
      $config['use_more_text'] = '';
      $component->setConfiguration($config);
    });
  }
}

/**
 * Clear all the caches.
 */
function sitenow_update_9027() {
  drupal_flush_all_caches();
}

/**
 * Change footer content block to minimal format.
 */
function sitenow_update_9028() {
  // Removed as part of https://github.com/uiowa/uiowa/pull/5324
}

/**
 * Flush all caches so drupal finds uiowa_auth module.
 */
function sitenow_update_9029() {
  drupal_flush_all_caches();
}

/**
 * Flush all caches after swapping colorbox with the photoswipe module.
 */
function sitenow_update_9030() {
  drupal_flush_all_caches();
}

/**
 * Clear plugin cache for photoswipe config import.
 */
function sitenow_update_9031() {
  /** @var \Drupal\Core\Plugin\CachedDiscoveryClearerInterface $plugin_cache_clearer */
  $plugin_cache_clearer = \Drupal::service('plugin.cache_clearer');
  $plugin_cache_clearer->clearCachedDefinitions();
}

/**
 * Clear caches to regenerate image styles.
 */
function sitenow_update_9032() {
  drupal_flush_all_caches();
}

/**
 * Create new headline field for headline alignment.
 */
function sitenow_update_9033() {
  $headline_alignment = [
    'type' => 'varchar',
    'description' => 'Alignment for the heading.',
    'length' => 255,
    'not null' => TRUE,
    'default' => '',
  ];
  $schema = Database::getConnection()->schema();
  $schema->addField('block_content__field_uiowa_headline', 'field_uiowa_headline_headline_alignment', $headline_alignment);
  $schema->addField('block_content_revision__field_uiowa_headline', 'field_uiowa_headline_headline_alignment', $headline_alignment);
}

/**
 * Set the newly created footer.login_link theme setting to TRUE.
 */
function sitenow_update_9034() {
  $config = \Drupal::configFactory()->getEditable('uids_base.settings');

  if (!$config->get('footer.login_link')) {
    $config->set('footer.login_link', TRUE)
      ->save();
  }
}

/**
 * Clean up media revisions.
 */
function sitenow_update_9035() {
  $db = \Drupal::database();
  $entity_manager = \Drupal::service('entity_type.manager')
    ->getStorage('media');
  // Get a vid->mid mapping from the media table.
  // This table holds a one-to-one mapping of the current
  // revision for each media id, so we know the associated
  // vid is the most current revision for each given mid.
  $vid_to_mid_map = $db->select('media')
    ->fields('media', ['vid', 'mid'])
    ->execute()
    ->fetchAllKeyed();
  // Now grab all the vids from the media_revision table
  // which were not present in the media table
  // as a current revision.
  $vids = $db->select('media_revision', 'mr')
    ->fields('mr', ['vid'])
    ->condition('vid', array_keys($vid_to_mid_map), 'NOT IN')
    ->execute()
    ->fetchCol();
  // Loop through the non-current vids
  // and delete them.
  foreach ($vids as $vid) {
    $entity_manager->deleteRevision($vid);
  }
}

/**
 * Set previously unset menu item styles to vertical.
 */
function sitenow_update_9036() {
  _update_all_blocks_by_plugin_id('menu_block:main', function (&$component, $block) {
    $styles = $component->get('layout_builder_styles_style');
    if (!isset($styles['block_menu_vertical']) && !isset($styles['block_menu_horizontal'])) {
      $styles['block_menu_vertical'] = 'block_menu_vertical';
    }

    $component->set('layout_builder_styles_style', $styles);
  });
}

/**
 * Flush all caches.
 */
function sitenow_update_9037() {
  drupal_flush_all_caches();
}

/**
 * Set existing blocks with a grid columns value.
 */
function sitenow_update_9038() {
  foreach ([
    'inline_block:uiowa_articles',
    'inline_block:uiowa_events',
    'inline_block:uiowa_people',
    'inline_block:uiowa_aggregator',
    'views_block:article_list_block-list_article',
    'views_block:people_list_block-list_card',
  ] as $block_plugin_id) {

    _update_all_blocks_by_plugin_id($block_plugin_id, function (&$component, $block) {

      $styles = $component->get('layout_builder_styles_style');
      if (in_array('list_format_list', $styles)) {
        if (!array_search('block_grid_threecol_33_34_33', $styles)) {
          $styles[] = 'block_grid_threecol_33_34_33';
        }

        if ($fifty_fifty = array_search('block_grid_twocol_50_50', $styles)) {
          unset($styles[$fifty_fifty]);
        }
      }
      $component->set('layout_builder_styles_style', $styles);

    });

  }
}

/**
 * Flush all caches for dependency updates.
 */
function sitenow_update_9039() {
  drupal_flush_all_caches();
}

/**
 * Flush all caches for dependency update signature changes.
 */
function sitenow_update_9040() {
  drupal_flush_all_caches();
}

/**
 * Set existing banner blocks with a default button style value.
 */
function sitenow_update_9041() {
  // Loop through our newly updated banner blocks.
  foreach ([
    'inline_block:uiowa_banner',
  ] as $block_plugin_id) {
    _update_all_blocks_by_plugin_id($block_plugin_id, function (&$component, $block) {

      $styles = $component->get('layout_builder_styles_style');
      // We shouldn't, but check if we have a button style already set.
      // If we do, we shouldn't make any changes.
      $style_exists = FALSE;
      foreach ($styles as $style) {
        if (str_starts_with($style, 'button_')) {
          $style_exists = TRUE;
        }
      }
      // If no button style was set, then add our new
      // default style and re-set the new complete styles.
      if (!$style_exists) {
        $styles[] = 'button_primary';
        $component->set('layout_builder_styles_style', $styles);
      }

    });

  }
}

/**
 * Flush all caches so drupal finds uiowa_auth module.
 */
function sitenow_update_9042() {
  drupal_flush_all_caches();
}

/**
 * Uninstall sitenow_find_text.
 */
function sitenow_update_9043() {
  \Drupal::service('module_installer')->uninstall(['sitenow_find_text']);
}

/**
 * Update button classes again.
 */
function sitenow_update_9044() {
  // Removed as part of https://github.com/uiowa/uiowa/pull/5324
}

/**
 * Flush all caches after the template changes in UIDS 4 pull request.
 */
function sitenow_update_9045() {
  drupal_flush_all_caches();
}

/**
 * Set existing events block to be compatible with new date_range options.
 */
function sitenow_update_9046() {
  // Need module enabled before field operations occur.
  \Drupal::service('module_installer')->install(['smart_date']);

  $config_path = DRUPAL_ROOT . '/../config/default';
  $source = new FileStorage($config_path);
  // See https://www.drupal.org/project/drupal/issues/2944144#comment-12481021.
  foreach (
    [
      'field.storage.block_content.field_uiowa_events_timeframe',
      'field.field.block_content.uiowa_events.field_uiowa_events_timeframe',
      'field.storage.block_content.field_uiowa_events_sort',
      'field.field.block_content.uiowa_events.field_uiowa_events_sort',
      'field.storage.block_content.field_uiowa_events_date_range',
      'field.field.block_content.uiowa_events.field_uiowa_events_date_range',
    ] as $config_name) {
    $config_record = $source->read($config_name);

    $entity_type = \Drupal::service('config.manager')
      ->getEntityTypeIdByName($config_name);
    /** @var \Drupal\Core\Config\Entity\ConfigEntityStorageInterface $storage */
    $storage = \Drupal::entityTypeManager()->getStorage($entity_type);
    $entity = $storage->createFromStorageRecord($config_record);
    $entity->save();
  }

  drupal_flush_all_caches();

  _update_all_blocks_by_plugin_id('inline_block:uiowa_events', function (&$component, $block) {
    $now = strtotime('now');
    $block->set(
      'field_uiowa_events_date_range', ['value' => $now, 'end_value' => $now]
    );
    if ((int) $block->get('field_uiowa_events_past')->value === 1) {
      $block->set('field_uiowa_events_sort', 'DESC');
      $block->set('field_uiowa_events_timeframe', 'past');
    }
    else {
      $block->set('field_uiowa_events_sort', 'ASC');
      $block->set('field_uiowa_events_timeframe', 'upcoming');
    }
    $block->save();
  });
}

/**
 * Update several fields from plain text to formatted basic text.
 */
function sitenow_update_9047() {

  // Statically defining our fields to be updated. More can be added here.
  $fields = [
    'field_uiowa_quote_content' => [
      'format_col' => 'field_uiowa_quote_content_format',
    ],
    'field_uiowa_quote_footer' => [
      'format_col' => 'field_uiowa_quote_footer_format',
    ],
  ];
  // Get the field and revision storage table names for each field.
  /** @var \Drupal\Core\Entity\Sql\DefaultTableMapping $table_mapping */
  $table_mapping = \Drupal::service('entity_type.manager')
    ->getStorage('block_content')
    ->getTableMapping();
  $storage_definitions = \Drupal::service('entity_field.manager')
    ->getActiveFieldStorageDefinitions('block_content');
  foreach ($fields as $field_name => &$field) {
    $field_definition = $storage_definitions[$field_name];
    if ($field_definition) {
      $field['table'] = $table_mapping->getDedicatedDataTableName($field_definition);
      $field['revision_table'] = $table_mapping->getDedicatedRevisionTableName($field_definition);
    }
  }

  $database = \Drupal::database();

  foreach ($fields as $field_name => &$field) {
    $table = $field['table'];
    $revision_table = $field['revision_table'];
    $entity_type = 'block_content';

    $field_storage = FieldStorageConfig::loadByName($entity_type, $field_name);
    if (is_null($field_storage)) {
      continue;
    }

    // Fetch data currently stored in the field and save for later.
    $rows = NULL;
    $revision_rows = NULL;
    if ($database->schema()->tableExists($table)) {
      $rows = $database
        ->select($table, 't')
        ->fields('t')
        ->execute()
        ->fetchAll();
      if ($database->schema()->tableExists($revision_table)) {
        $revision_rows = $database
          ->select($revision_table, 'r')
          ->fields('r')
          ->execute()
          ->fetchAll();
      }
    }

    $new_fields = [];
    $weights = [];
    foreach ($field_storage->getBundles() as $bundle => $label) {
      /** @var \Drupal\field\Entity\FieldConfig $old_field */
      $old_field = FieldConfig::loadByName($entity_type, $bundle, $field_name);
      $new_field = $old_field->toArray();
      $new_field['field_type'] = 'text_long';
      $new_field['settings'] = [];
      $new_fields[] = $new_field;
      // Get the view display weights so we can re-set them later.
      $entity_view = $entity_type . '.' . $bundle . '.default';
      $view_display = \Drupal::entityTypeManager()
        ->getStorage('entity_view_display')
        ->load($entity_view)
        ->getComponent($field_name);
      $weights['entity_view_display'][$entity_view] = $view_display['weight'];
      // Get the form display weights so we can re-set them later.
      $form_display = \Drupal::entityTypeManager()
        ->getStorage('entity_form_display')
        ->load($entity_type . '.' . $bundle . '.default')
        ->getComponent($field_name);
      $weights['entity_form_display'][$entity_type . '.' . $bundle . '.default'] = $form_display['weight'];
    }

    // Store the old field settings and update to text_long.
    $new_field_storage = $field_storage->toArray();
    $new_field_storage['type'] = 'text_long';
    $new_field_storage['settings'] = [];
    // Deleting at the field_storage level takes care of the bundles as well.
    $field_storage->delete();

    // Purge in order for new field to be created after deleting the old.
    field_purge_batch(100);

    // Save our new, updated field storage.
    $new_field_storage = FieldStorageConfig::create($new_field_storage);
    $new_field_storage->save();

    // Create our new fields to match the field storages.
    foreach ($new_fields as $new_field) {
      $new_field_config = FieldConfig::create($new_field);
      $new_field_config->save();
    }

    // Replace into the new fields data we saved from the old fields.
    if (!is_null($rows)) {
      foreach ($rows as $row) {
        $row = (array) $row;
        $row[$field['format_col']] = 'basic';
        $database
          ->insert($table)
          ->fields($row)
          ->execute();
      }
    }
    if (!is_null($revision_rows)) {
      foreach ($revision_rows as $row) {
        $row = (array) $row;
        $row[$field['format_col']] = 'basic';
        $database
          ->insert($revision_table)
          ->fields($row)
          ->execute();
      }
    }

    // Update the view and form display weights, which enables the new fields.
    foreach ($weights as $display_mode => $view_modes) {
      foreach ($view_modes as $view_mode => $weight) {
        if ($weight) {
          $layout_display = \Drupal::entityTypeManager()
            ->getStorage($display_mode)
            ->load($view_mode);
          if ($layout_display instanceof EntityDisplayInterface) {
            $layout_display->setComponent($field_name, [
              'weight' => $weight,
            ])
              ->save();
          }
        }
      }
    }
  }
}

/**
 * Flush all caches after removing 175 logo and restoring regular logo.
 */
function sitenow_update_9048() {
  drupal_flush_all_caches();
}

/**
 * Add article to replicate allowed content types.
 */
function sitenow_update_9049() {
  /** @var \Drupal\config_split\Entity\ConfigSplitEntity $config_split_entities */
  $sitenow_v2 = \Drupal::entityTypeManager()->getStorage('config_split')->load('sitenow_v2');
  $sitenow_v2->get('status');

  // This site has the 'sitenow_v2' split in config,
  // and it is enabled.
  if ($sitenow_v2 && $sitenow_v2->get('status')) {
    $config_factory = \Drupal::configFactory();
    $config = $config_factory->getEditable('uiowa_core.settings');
    $config
      ->set('uiowa_core.replicate_allowed', ['article'])
      ->save();
  }
}

/**
 * Flush all caches because reasons.
 */
function sitenow_update_9050() {
  drupal_flush_all_caches();
}

/**
 * Update card excerpt field format to the new minimal_plus format.
 */
function sitenow_update_9051() {
  _update_all_blocks_by_plugin_id('inline_block:uiowa_card', function (&$component, $block) {

    // Change the format for the card excerpt.
    if (!is_null($block)) {
      $block->field_uiowa_card_excerpt->format = 'minimal_plus';
      $block->save();
    }
  });
}

/**
 * Import updated config ignore before site specific config is removed.
 */
function sitenow_update_9052() {
  $config_path = DRUPAL_ROOT . '/../config/default';
  $source = new FileStorage($config_path);
  $config_storage = \Drupal::service('config.storage');
  $config_storage->write('config_ignore.settings', $source->read('config_ignore.settings'));
}

/**
 * Re-run of 9051 to fix recently provisioned sites.
 */
function sitenow_update_9053() {
  _update_all_blocks_by_plugin_id('inline_block:uiowa_card', function (&$component, $block) {

    // Change the format for the card excerpt.
    if (!is_null($block)) {
      if ($block->get('field_uiowa_card_excerpt')->format !== 'minimal_plus') {
        $block->field_uiowa_card_excerpt->format = 'minimal_plus';
        $block->save();
      }
    }
  });
}

/**
 * Import updated acquia_connector.settings around config_ignore.
 */
function sitenow_update_9054() {
  $config_path = DRUPAL_ROOT . '/../config/default';
  $source = new FileStorage($config_path);
  $config_storage = \Drupal::service('config.storage');
  $config_storage->write('acquia_connector.settings', $source->read('acquia_connector.settings'));
}

/**
 * Set new style-selector theme setting.
 */
function sitenow_update_9055() {
  $config_factory = \Drupal::configFactory();
  $config = $config_factory->getEditable('uids_base.settings');
  $config->set('style.style_selector', 'brand');
  $config->save();
}

/**
 * Convert layout_section fields' 'section' column to a long blob.
 */
function sitenow_update_9056() {
  $schema = Database::getConnection()->schema();
  $entity_type_manager = \Drupal::entityTypeManager();
  /** @var \Drupal\Core\Entity\EntityFieldManagerInterface $entity_field_manager */
  $entity_field_manager = \Drupal::service('entity_field.manager');
  $field_map = $entity_field_manager->getFieldMapByFieldType('layout_section');
  $storage_schema = \Drupal::keyValue('entity.storage_schema.sql');
  /** @var \Drupal\Core\Entity\EntityLastInstalledSchemaRepositoryInterface $last_installed_schema */
  $last_installed_schema = \Drupal::service('entity.last_installed_schema.repository');

  // The new schema to use for the section column.
  $new_column_schema = [
    'type' => 'blob',
    'size' => 'big',
    'serialize' => TRUE,
  ];
  foreach ($field_map as $entity_type_id => $layout_section_fields) {
    $entity_storage = $entity_type_manager->getStorage($entity_type_id);

    // Skip this entity type if it does not use SQL-based storage.
    if (!$entity_storage instanceof SqlEntityStorageInterface) {
      continue;
    }

    $entity_type = $entity_type_manager->getDefinition($entity_type_id);
    // Load all field storage definitions for the entity type.
    $field_storage_definitions = $entity_field_manager->getFieldStorageDefinitions($entity_type_id);
    /** @var \Drupal\Core\Entity\Sql\DefaultTableMapping $table_mapping */
    $table_mapping = $entity_storage->getTableMapping($field_storage_definitions);

    // Get the field storage definitions for all the layout_section fields.
    $field_storage_definitions = array_intersect_key($field_storage_definitions, $layout_section_fields);

    // Iterate over each layout_section field definition.
    /** @var \Drupal\Core\Field\FieldStorageDefinitionInterface $field_storage_definition */
    foreach ($field_storage_definitions as $field_storage_definition) {
      $field_name = $field_storage_definition->getName();

      // Determine which tables we need to update.
      $tables = [
        $table_mapping->getFieldTableName($field_name),
      ];
      if ($entity_type->isRevisionable() && $field_storage_definition->isRevisionable()) {
        $tables[] = $table_mapping->getDedicatedRevisionTableName($field_storage_definition);
      }

      // Alter the database column for each of the tables.
      $column_name = $table_mapping->getColumnNames($field_name)['section'];
      foreach ($tables as $table) {
        $schema->changeField($table, $column_name, $column_name, $new_column_schema);
      }

      // Update the tracked entity table schema.
      $schema_key = "$entity_type_id.field_schema_data.$field_name";
      $schema_data = $storage_schema->get($schema_key);
      foreach ($schema_data as $table_name => $field_schema) {
        $schema_data[$table_name]['fields'][$column_name]['size'] = 'big';
      }
      $storage_schema->set($schema_key, $schema_data);

      // Update cached entity definitions for entity types with
      // single-cardinality base fields.
      if ($table_mapping->allowsSharedTableStorage($field_storage_definition)) {
        $last_installed_schema->setLastInstalledFieldStorageDefinition($field_storage_definition);
      }
    }
  }
}

/**
 * Update layout builder styles applied to cards.
 */
function sitenow_update_9057() {
  // Apply updates to all blocks that are styled using card styles.
  _update_all_blocks_by_plugin_id([
    'inline_block:uiowa_card',
    'inline_block:uiowa_event',
    'inline_block:uiowa_events',
    'inline_block:uiowa_aggregator',
    'views_block:article_list_block-list_article',
    'views_block:people_list_block-list_card',
    'views_block:events_list_block-card_list',
  ], function (&$component, $block) {
    /** @var \Drupal\layout_builder\SectionComponent $component */
    // @phpstan-ignore-next-line
    $styles = $component->get('layout_builder_styles_style');

    // If styles aren't set, then initialize them.
    if (empty($styles)) {
      $styles = [];
    }

    // If card border style is set...
    $border_index = array_search('block_card_style_border', $styles);
    if ($border_index !== FALSE) {
      // Unset it.
      unset($styles[$border_index]);
    }
    else {
      // Add style for no border option.
      $styles[] = 'no_border';
    }

    if ($component->getPluginId() !== 'inline_block:uiowa_event') {
      // Update card_image_* to media_size_*.
      $media_size_set = FALSE;
      foreach ([
        'card_image_large',
        'card_image_medium',
        'card_image_small',
      ] as $card_image_size) {
        $card_image_size_index = array_search($card_image_size, $styles);
        if ($card_image_size_index !== FALSE) {
          $size = str_replace('card_image_', '', $styles[$card_image_size_index]);
          $styles[$card_image_size_index] = "media_size_$size";
          $media_size_set = TRUE;
        }
      }

      // Set a default media size if not already set.
      if (!$media_size_set) {
        $styles[] = 'media_size_small';
      }

      // Set default headline styles for card blocks.
      if ($component->getPluginId() === 'inline_block:uiowa_card') {
        if (in_array('card_media_position_stacked', $styles)) {
          $styles[] = 'card_headline_style_sans_serif';
        }
        else {
          $styles[] = 'card_headline_style_serif';
        }
      }

      // Remove content alignment style.
      if (FALSE !== $remove_style_index = array_search('content_alignment_left', $styles)) {
        unset($styles[$remove_style_index]);
      }
    }

    // Still need to maintain this other set of styles for AJAX view pagers.
    // @phpstan-ignore-next-line
    $configuration = $component->get('configuration');
    $configuration['layout_builder_styles'] = array_filter($styles);

    // Map block bundle to entity bundle class.
    $class_map = [
      'uiowa_card' => Card::class,
      'uiowa_event' => Event::class,
    ];

    // If the block is serialized, we need to recreate it.
    if (isset($configuration['block_serialized']) && isset($class_map[$block->bundle()])) {
      // Recreate the block using the appropriate entity class.
      $block = call_user_func_array($class_map[$block->bundle()] . '::create', [$block->toArray()]);
      // Re-serialize the block so that it gets hydrated using the right class.
      $configuration['block_serialized'] = serialize($block);
    }

    $component->setConfiguration($configuration);

    // Save updated styles.
    // @phpstan-ignore-next-line
    $component->set('layout_builder_styles_style', array_filter($styles));
  });
}

/**
 * Update sections with only cards to remove "Remove bottom spacing" style.
 */
function sitenow_update_9058(&$sandbox) {

  $block_plugin_id = 'inline_block:uiowa_card';

  $db = \Drupal::database();

  $section_column = 'layout_builder__layout_section';
  $tables = [
    'node__layout_builder__layout',
    'node_revision__layout_builder__layout',
  ];

  foreach ($tables as $table_name) {
    // Select DB records for our $table_name.
    $query = $db->select($table_name, 'n');

    $query = $query
      ->condition($section_column, "%$block_plugin_id%", 'LIKE')
      ->condition($section_column, '%remove_default_bottom_padding%', 'LIKE')
      ->fields('n', ['entity_id', 'revision_id', 'delta', $section_column]);

    $count = $query->countQuery()->execute()->fetchField();

    \Drupal::messenger()
      ->addMessage(t('Sections with blocks of @types records found in @table: @count', [
        '@types' => $block_plugin_id,
        '@table' => $table_name,
        '@count' => $count,
      ]));

    $results = $query->execute();

    // Loop through the results.
    foreach ($results as $record) {
      // Unserialize the section field into it's class object.
      /** @var \Drupal\layout_builder\Section $section */
      $section = unserialize($record->{$section_column}, [
        'allowed_classes' => TRUE,
      ]);

      $all_cards = TRUE;

      // Loop through the components in the section.
      foreach ($section->getComponents() as &$component) {

        // Limit this to only the initial list of block plugins.
        if ($component->getPluginId() !== $block_plugin_id) {
          $all_cards = FALSE;
        }
      }

      if ($all_cards) {
        $config = $section->getLayoutSettings();
        if (isset($config['layout_builder_styles_style']) && !is_null($key = array_search('remove_default_bottom_padding', $config['layout_builder_styles_style']))) {
          unset($config['layout_builder_styles_style'][$key]);
          $section->setLayoutSettings($config);
        }
      }
      // Serialize section component and update section component db record.
      // Replace the old section with our newly created one.
      $db->update($table_name)
        ->condition('revision_id', $record->revision_id)
        ->condition('delta', $record->delta)
        ->fields([
          $section_column => serialize($section),
        ])
        ->execute();
    }
  }

  // Only continue with this section if we have a key_value_expire
  // table to work with.
  if ($db->schema()->tableExists('key_value_expire')) {
    // Check if we have a tempstore of this node.
    // Temp store is saved in the db in the key_value_expire,
    // And holds a serialized blob with the unsaved changes.
    // Might be a better method of accessing this through the Layout
    // Builder API and layoutTempstoreRepository, but have not found it yet.
    $query = $db->select('key_value_expire', 'kve')
      ->fields('kve')
      ->condition('collection', 'tempstore.shared.layout_builder.section_storage.overrides', '=')
      ->condition('value', "%$block_plugin_id%", 'LIKE');

    $count = $query->countQuery()->execute()->fetchField();

    \Drupal::messenger()
      ->addMessage(t('Tempstore records for sections with blocks of @types records found: @count', [
        '@types' => $block_plugin_id,
        '@count' => $count,
      ]));

    $results = $query
      ->execute();

    foreach ($results as $record) {

      // Unserialize and replace the section in question with our updated one.
      $stored_data = unserialize($record->value, [
        'allowed_classes' => TRUE,
      ]);

      /** @var \Drupal\layout_builder\Plugin\SectionStorage\OverridesSectionStorage $section_storage */
      $section_storage = $stored_data->data['section_storage'];

      // Loop through sections in the storage.
      foreach ($section_storage->getSections() as &$section) {

        $all_cards = TRUE;

        // Loop through the components in the section.
        foreach ($section->getComponents() as &$component) {

          // Limit this to only the initial list of block plugins.
          if ($component->getPluginId() !== $block_plugin_id) {
            $all_cards = FALSE;
          }
        }

        if ($all_cards) {
          $config = $section->getLayoutSettings();
          if (isset($config['layout_builder_styles_style']) && !is_null($key = array_search('remove_default_bottom_padding', $config['layout_builder_styles_style']))) {
            unset($config['layout_builder_styles_style'][$key]);
            $section->setLayoutSettings($config);
          }
        }
      }
      $stored_data->data['section_storage'] = $section_storage;

      // Insert the updated tempstore.
      $db->update('key_value_expire')
        ->condition('name', $record->name, '=')
        ->condition('expire', $record->expire, '=')
        ->fields([
          'value' => serialize($stored_data),
        ])
        ->execute();
    }
  }
}

/**
 * Set defaults for card headline styles.
 */
function sitenow_update_9059(&$sandbox) {
  _update_all_blocks_by_plugin_id([
    'inline_block:uiowa_events',
    'inline_block:uiowa_aggregator',
    'views_block:article_list_block-list_article',
    'views_block:people_list_block-list_card',
    'views_block:events_list_block-card_list',
  ], function (&$component, $block) {
    /** @var \Drupal\layout_builder\SectionComponent $component */
    // @phpstan-ignore-next-line
    $styles = $component->get('layout_builder_styles_style');

    if (empty($styles)) {
      $styles = [];
    }

    if (in_array('card_media_position_stacked', $styles)) {
      $styles[] = 'card_headline_style_sans_serif';
    }
    else {
      $styles[] = 'card_headline_style_serif';
    }

    // Still need to maintain this other set of styles for AJAX view pagers.
    // @phpstan-ignore-next-line
    $configuration = $component->get('configuration');
    $configuration['layout_builder_styles'] = array_filter($styles);

    $component->setConfiguration($configuration);

    // Save updated styles.
    // @phpstan-ignore-next-line
    $component->set('layout_builder_styles_style', array_filter($styles));
  });
}

/**
 * Update search blocks to be aware of new fields.
 */
function sitenow_update_9060() {
  _update_all_blocks_by_plugin_id('uiowa_core_search_block', function (&$component, $block) {

    $config = $component->get('configuration');
    $config['query_prepend'] = '';
    $config['additional_parameters'] = '';
    $component->setConfiguration($config);

  });
}

/**
 * Actively import the new field config if Event feature is active.
 */
function sitenow_update_9061() {
  /** @var Drupal\Core\Config\ImmutableConfig $config */
  $config = \Drupal::service('config_split.manager')->getSplitConfig('config_split.config_split.event');

  // If event split isn't registered or
  // isn't active, return early.
  if (!isset($config) || !$config->get('status')) {
    return t('event split is not active, so no update to run.');
  }

  /** @var Drupal\Core\Config\CachedStorage $config_storage */
  $config_storage = \Drupal::service('config.storage');

  if (!$config_storage->read('field.storage.node.field_event_attendance_mode')) {
    $config_path = DRUPAL_ROOT . '/../config/features/event';
    $source = new FileStorage($config_path);

    $field_storage_link = $source->read('field.storage.node.field_event_attendance_mode');

    // There's an extra layer of nesting in how the config is read,
    // so do some quick tidying.
    $allowed_values_link = [];
    foreach ($field_storage_link['settings']['allowed_values'] as $value) {
      $allowed_values_link[$value['value']] = $value['label'];
    }
    $field_storage_link['settings']['allowed_values'] = $allowed_values_link;

    \Drupal::entityTypeManager()->getStorage('field_storage_config')
      ->create($field_storage_link)
      ->save();

    $field_type_link = $source->read('field.field.node.event.field_event_attendance_mode');
    \Drupal::entityTypeManager()->getStorage('field_config')->create($field_type_link)->save();
  }
}

/**
 * Update new field values if Event split is active.
 */
function sitenow_update_9062(&$sandbox) {
  /** @var Drupal\Core\Config\ImmutableConfig $config */
  $config = \Drupal::service('config_split.manager')->getSplitConfig('config_split.config_split.event');

  // If event split isn't registered or
  // isn't active, return early.
  if (!isset($config) || !$config->get('status')) {
    return t('event split is not active, so no update to run.');
  }

  // Process all event nodes to update the value
  // for our new field.
  if (!isset($sandbox['total'])) {
    $query = \Drupal::entityQuery('node')
      ->accessCheck(TRUE)
      ->condition('type', 'event')
      ->execute();

    $sandbox['total'] = count($query);
    $sandbox['current'] = 0;
    $sandbox['query'] = $query;

    if (empty($sandbox['total'])) {
      $sandbox['#finished'] = 1;
      return;
    }
  }
  // Loop through the same nodes in batches.
  $nodes_per_batch = 25;
  $batch = array_slice($sandbox['query'], $sandbox['current'], $sandbox['current'] + $nodes_per_batch);
  if (empty($batch)) {
    $sandbox['#finished'] = 1;
    return;
  }

  foreach ($batch as $nid) {
    $node = Node::load($nid);
    // See if we have a location and/or virtual filled out.
    $location = !is_null($node->field_event_location->get(0));
    $virtual = !is_null($node->field_event_virtual->get(0));
    // Default to our in-person option.
    $value = 'OfflineEventAttendanceMode';
    if ($virtual) {
      // If both fields are filled, we're hybrid.
      if ($location) {
        $value = 'MixedEventAttendanceMode';
      }
      // If only virtual was filled, we're online.
      else {
        $value = 'OnlineEventAttendanceMode';
      }
    }
    // Set the new value and revision message, and save.
    $node->set('field_event_attendance_mode', $value);
    $node->setRevisionLogMessage('Automated save.');
    $node->setRevisionUserId(1);
    $node->save();
    $sandbox['current']++;
  }

  \Drupal::messenger()
    ->addMessage($sandbox['current'] . ' nodes processed.');

  if ($sandbox['current'] >= $sandbox['total']) {
    $sandbox['#finished'] = 1;
  }
  else {
    $sandbox['#finished'] = ($sandbox['current'] / $sandbox['total']);
  }

}

/**
 * Allow event content type to be replicated if it exists.
 */
function sitenow_update_9063() {
  $config_factory = \Drupal::configFactory();
  $config = $config_factory->getEditable('uiowa_core.settings');
  $replicate_allowed = $config->get('uiowa_core.replicate_allowed');
  $replicate_allowed[] = 'event';
  $config
    ->set('uiowa_core.replicate_allowed', $replicate_allowed)
    ->save();
}

/**
 * Update any existing cards where button display is not set.
 */
function sitenow_update_9064() {
  _update_all_blocks_by_plugin_id('inline_block:uiowa_card', function (&$component, BlockContentInterface $block) {
    if ($block->get('field_uiowa_card_button_display')->value == NULL) {
      $block->set('field_uiowa_card_button_display', 'Use site default');
      $block->save();
    }
  });
}

/**
 * Set list grid defaults for existing featured content blocks.
 */
function sitenow_update_9065() {
  _update_all_blocks_by_plugin_id('inline_block:featured_content', function (&$component, $block) {
    // @phpstan-ignore-next-line
    $styles = $component->get('layout_builder_styles_style');
    $styles[] = 'list_format_list';
    $styles[] = 'block_grid_threecol_33_34_33';
    $styles[] = 'no_border';

    // @phpstan-ignore-next-line
    $component->set('layout_builder_styles_style', $styles);

  });
}

/**
 * Update alert classes.
 */
function sitenow_update_9067() {
  $search_replace = [
    'alert-danger' => 'alert--danger',
    'alert-warning' => 'alert--warning',
    'alert-success' => 'alert--success',
    'alert-info' => 'alert--info',
  ];

  $entity_type_manager = \Drupal::entityTypeManager();
  $entity_field_manager = \Drupal::service('entity_field.manager');
  $text_long = $entity_field_manager->getFieldMapByFieldType('text_long');
  $text_with_summary = $entity_field_manager->getFieldMapByFieldType('text_with_summary');
  $entity_field_map = array_merge($text_long, $text_with_summary);

  foreach ($entity_field_map as $entity_type_id => $field_map) {
    $entity_storage = $entity_type_manager->getStorage($entity_type_id);
    if (!($entity_storage instanceof SqlContentEntityStorage)) {
      continue;
    }

    $entity_type = $entity_type_manager->getDefinition($entity_type_id);
    $field_storage_definitions = $entity_field_manager->getFieldStorageDefinitions($entity_type_id);
    $table_mapping = $entity_storage->getTableMapping($field_storage_definitions);
    foreach (array_intersect_key($field_storage_definitions, $field_map) as $field_storage_definition) {
      $tables = [];
      $field_name = $field_storage_definition->getName();
      try {
        $tables[] = $table_mapping->getFieldTableName($field_name);
        $value_column = $table_mapping->getFieldColumnName($field_storage_definition, 'value');
      }
      catch (SqlContentEntityStorageException $e) {
        continue;
      }
      // See if the field has a revision table.
      $revision_table = NULL;
      if ($entity_type->isRevisionable() && $field_storage_definition->isRevisionable()) {
        if ($table_mapping->requiresDedicatedTableStorage($field_storage_definition)) {
          $revision_table = $table_mapping->getDedicatedRevisionTableName($field_storage_definition);
        }
        elseif ($table_mapping->allowsSharedTableStorage($field_storage_definition)) {
          $revision_table = $entity_type->getRevisionDataTable() ?: $entity_type->getRevisionTable();
        }
        $tables[] = $revision_table;
      }
      if (!empty($tables)) {
        $db = \Drupal::database();

        foreach ($tables as $table) {
          $update_count = 0;
          $query = $db->select($table, 't')
            ->fields('t');

          // Build a condition group from our search strings.
          $or_group = $query->orConditionGroup();

          foreach ($search_replace as $needle => $string) {
            $or_group->condition($value_column, '%' . $db->escapeLike($needle) . '%', 'LIKE');
          }

          $results = $query->condition($or_group)
            ->execute();

          foreach ($results as $record) {

            // Load the HTML fragment as a DOMDocument object.
            $document = Html::load($record->{$value_column});

            // Get all <div> elements from the HTML fragment.
            $instances = $document->getElementsByTagName('div');

            // A regressive loop (starting with the end) is used to loop
            // through matching elements so that they don't affect other
            // elements when they are updated.
            $i = $instances->length - 1;

            while ($i >= 0) {
              // The current <div> element.
              $dom_element = $instances->item($i);

              $class = $dom_element->getAttribute('class');

              foreach ($search_replace as $needle => $replace) {
                $class = str_replace($needle, $replace, $class);
              }

              if (trim($class)) {
                $dom_element->setAttribute('class', $class);
              }
              else {
                $dom_element->removeAttribute('class');
              }

              $i--;
            }

            // Run database update to store updated $value_column as
            // Html::serialize($document).
            $db->update($table)
              ->fields([
                $value_column => Html::serialize($document),
              ])
              ->condition('entity_id', $record->entity_id)
              ->condition('revision_id', $record->revision_id)
              ->execute();

            $update_count++;
          }

          if ($update_count) {
            \Drupal::messenger()
              ->addMessage('Processed ' . $update_count . ' update(s) for ' . $table . ' table ' . $value_column . ' column.');
          }
        }
      }
    }
  }
}

/**
 * Update person bio field to long with summary.
 */
function sitenow_update_9068() {

  // Statically defining our fields to be updated. More can be added here.
  $fields = [
    'field_person_bio' => [
      'format_col' => 'field_person_bio_format',
      'summary_col' => 'field_person_bio_summary',
      'value_col' => 'field_person_bio_value',
    ],
  ];
  // Get the field and revision storage table names for each field.
  /** @var \Drupal\Core\Entity\Sql\DefaultTableMapping $table_mapping */
  $table_mapping = \Drupal::service('entity_type.manager')
    ->getStorage('node')
    ->getTableMapping();
  $storage_definitions = \Drupal::service('entity_field.manager')
    ->getActiveFieldStorageDefinitions('node');

  foreach ($fields as $field_name => &$field) {
    $field_definition = $storage_definitions[$field_name];
    if ($field_definition) {
      $field['table'] = $table_mapping->getDedicatedDataTableName($field_definition);
      $field['revision_table'] = $table_mapping->getDedicatedRevisionTableName($field_definition);
    }
  }

  $database = \Drupal::database();

  foreach ($fields as $field_name => &$field) {
    $table = $field['table'];
    $revision_table = $field['revision_table'];
    $entity_type = 'node';

    $field_storage = FieldStorageConfig::loadByName($entity_type, $field_name);
    if (is_null($field_storage)) {
      continue;
    }

    // Fetch data currently stored in the field and save for later.
    $rows = NULL;
    $revision_rows = NULL;
    if ($database->schema()->tableExists($table)) {
      $rows = $database
        ->select($table, 't')
        ->fields('t')
        ->execute()
        ->fetchAll();
      if ($database->schema()->tableExists($revision_table)) {
        $revision_rows = $database
          ->select($revision_table, 'r')
          ->fields('r')
          ->execute()
          ->fetchAll();
      }
    }

    // Place into the body database, as after config import
    // that will be the person body location.
    if (!is_null($rows)) {
      foreach ($rows as $row) {
        $row = (array) $row;
        $row['body_format'] = 'filtered_html';
        // Set a blank summary. It'll be updated in the next update hook.
        $row['body_summary'] = '';
        $row['body_value'] = $row[$field['value_col']];
        foreach ($field as $col_name) {
          unset($row[$col_name]);
        }
        $database
          ->insert('node__body')
          ->fields($row)
          ->execute();
      }
    }
    if (!is_null($revision_rows)) {
      foreach ($revision_rows as $row) {
        $row = (array) $row;
        $row['body_format'] = 'filtered_html';
        // Set a blank summary. It'll be updated in the next update hook.
        $row['body_summary'] = '';
        $row['body_value'] = $row[$field['value_col']];
        foreach ($field as $col_name) {
          unset($row[$col_name]);
        }
        $database
          ->insert('node_revision__body')
          ->fields($row)
          ->execute();
      }
    }
  }
}

/**
 * Update summary cols with field_teaser values.
 */
function sitenow_update_9069() {
  $field_types = [
    'body',
    'field_teaser',
  ];

  // Get the field and revision storage table names for each field.
  /** @var \Drupal\Core\Entity\Sql\DefaultTableMapping $table_mapping */
  $table_mapping = \Drupal::service('entity_type.manager')
    ->getStorage('node')
    ->getTableMapping();
  $storage_definitions = \Drupal::service('entity_field.manager')
    ->getActiveFieldStorageDefinitions('node');
  foreach ($field_types as $field_name) {
    $field_definition = $storage_definitions[$field_name];
    if ($field_definition) {
      $field_types[$field_name]['table'] = $table_mapping->getDedicatedDataTableName($field_definition);
      $field_types[$field_name]['revision_table'] = $table_mapping->getDedicatedRevisionTableName($field_definition);
    }
  }

  $database = \Drupal::database();

  $teaser_table = $field_types['field_teaser']['table'];
  $teaser_revision_table = $field_types['field_teaser']['revision_table'];
  $table = $field_types['body']['table'];
  $revision_table = $field_types['body']['revision_table'];
  if ($database->schema()->tableExists($teaser_table) && $database->schema()->tableExists($table) && $database->schema()->tableExists('node')) {
    $database->query("
      UPDATE {$teaser_table}, {$table}
      SET {$table}.body_summary = {$teaser_table}.field_teaser_value
      WHERE {$table}.entity_id = {$teaser_table}.entity_id
      AND {$table}.bundle = {$teaser_table}.bundle
      AND {$table}.revision_id = {$teaser_table}.revision_id
      AND {$teaser_table}.field_teaser_value <> ''
      AND ({$teaser_table}.field_teaser_value <> {$table}.body_summary OR {$table}.body_summary IS NULL)
    ")
      ->execute();
    // Updates body_summary for any nodes not already
    // in tables due to empty body.
    $database->query("
      INSERT IGNORE INTO {$table} ({$table}.bundle, {$table}.deleted, {$table}.entity_id, {$table}.revision_id, {$table}.langcode, {$table}.delta, {$table}.body_value, {$table}.body_summary, {$table}.body_format)
      SELECT {$teaser_table}.bundle, {$teaser_table}.deleted, {$teaser_table}.entity_id, {$teaser_table}.revision_id, {$teaser_table}.langcode, {$teaser_table}.delta, '', {$teaser_table}.field_teaser_value, 'filtered_html'
      FROM {$teaser_table}
      WHERE entity_id IN (SELECT nid FROM node WHERE nid NOT IN (SELECT DISTINCT entity_id FROM node__body))
    ")
      ->execute();
    if ($database->schema()->tableExists($teaser_revision_table) && $database->schema()->tableExists($revision_table)) {
      $database->query("
        UPDATE {$teaser_revision_table}, {$revision_table}
        SET {$revision_table}.body_summary = {$teaser_revision_table}.field_teaser_value
        WHERE {$revision_table}.revision_id = {$teaser_revision_table}.revision_id
        AND {$revision_table}.bundle = {$teaser_revision_table}.bundle
        AND {$revision_table}.entity_id = {$teaser_revision_table}.entity_id
        AND {$teaser_revision_table}.field_teaser_value <> ''
        AND ({$teaser_revision_table}.field_teaser_value <> {$revision_table}.body_summary OR {$revision_table}.body_summary IS NULL)
      ")
        ->execute();
      $database->query("
        INSERT IGNORE INTO {$revision_table} ({$revision_table}.bundle, {$revision_table}.deleted, {$revision_table}.entity_id, {$revision_table}.revision_id, {$revision_table}.langcode, {$revision_table}.delta, {$revision_table}.body_value, {$revision_table}.body_summary, {$revision_table}.body_format)
        SELECT {$teaser_revision_table}.bundle, {$teaser_revision_table}.deleted, {$teaser_revision_table}.entity_id, {$teaser_revision_table}.revision_id, {$teaser_revision_table}.langcode, {$teaser_revision_table}.delta, '', {$teaser_revision_table}.field_teaser_value, 'filtered_html'
        FROM $teaser_revision_table
        WHERE entity_id IN (SELECT nid FROM node WHERE nid NOT IN (SELECT DISTINCT entity_id FROM node_revision__body))
      ")
        ->execute();
    }
  }
}

/**
 * Update hide fields options for list blocks.
 */
function sitenow_update_9070() {
  foreach ([
    'views_block:article_list_block-list_article',
    'views_block:people_list_block-list_card',
    'views_block:events_list_block-list_card',
  ] as $block_plugin_id) {
    _update_all_blocks_by_plugin_id($block_plugin_id, function (&$component) {
      $config = $component->getConfiguration();
      $config['fields']['body'] = $config['fields']['field_teaser'];
      unset($config['fields']['field_teaser']);
      $component->setConfiguration($config);
    });
  }
}

/**
 * Set new branding options theme setting.
 */
function sitenow_update_9071() {
  $config_factory = \Drupal::configFactory();
  $config = $config_factory->getEditable('uids_base.settings');
  if ($config->get('style.style_selector') === 'gray') {
    $config->set('header.branding_options', 'regents');
  }
  else {
    $config->set('header.branding_options', 'iowa');
  }
  $config->save();
}

/**
 * Set existing image gallery blocks with default media size value.
 */
function sitenow_update_9072() {
  $block_plugin_id = 'inline_block:uiowa_image_gallery';

  _update_all_blocks_by_plugin_id($block_plugin_id, function (&$component, $block) {
    $styles = $component->get('layout_builder_styles_style');
    if (in_array('block_image_gallery_style_masonry', $styles)) {
      $styles[] = 'media_format_no_crop';
    }
    else {
      $styles[] = 'media_format_square';
    }
    $component->set('layout_builder_styles_style', $styles);
  });
}

/**
 * Update padding options for single select.
 */
function sitenow_update_9073() {
  foreach ([
    'inline_block:uiowa_text_area',
    'webform_block',
  ] as $block_plugin_id) {

    _update_all_blocks_by_plugin_id($block_plugin_id, function (&$component, $block) {
      $styles = $component->get('layout_builder_styles_style');

      if (is_array($styles)) {

        $has_padding_all_extra = in_array('block_padding_all_extra', $styles);
        $has_padding_all = in_array('block_padding_all', $styles);

        // Match expression to determine the styles.
        $final_styles = match (TRUE) {
          $has_padding_all_extra => ['block_padding_all_extra'],
          $has_padding_all => ['block_padding_all'],
          default => [],
        };

        // If both 'block_padding_all_extra' and 'block_padding_all'
        // are selected, remove 'block_padding_all'.
        if ($has_padding_all_extra && $has_padding_all) {
          $styles = array_diff($styles, ['block_padding_all']);
        }

        $styles = array_unique(array_merge($styles, $final_styles));

        $component->set('layout_builder_styles_style', $styles);
      }
    });
  }
}

/**
 * Remove the dependency on oembed_providers from remote video media type.
 */
function sitenow_update_9074() {
  $config_path = DRUPAL_ROOT . '/../config/default';
  $source = new FileStorage($config_path);

  // The following config is needed for the next update.
  $config_names = [
    'media.type.remote_video',
  ];
  $config_storage = \Drupal::service('config.storage');
  foreach ($config_names as $config_name) {
    $config_storage->write($config_name, $source->read($config_name));
  }
}

/**
 * Update config before module is uninstalled.
 */
function sitenow_update_9075() {
  $config_path = DRUPAL_ROOT . '/../config/default';
  $source = new FileStorage($config_path);

  // The following config is needed for the next update.
  $config_names = [
    'filter.format.filtered_html',
    'filter.format.full_html',
  ];
  $config_storage = \Drupal::service('config.storage');
  foreach ($config_names as $config_name) {
    $config_storage->write($config_name, $source->read($config_name));
  }
}

/**
 * Flush all caches after swapping colorbox with the photoswipe module.
 */
function sitenow_update_9076() {
  drupal_flush_all_caches();
}

/**
 * Update node type conditions from node_type to entity_bundle.
 */
function sitenow_update_10001() {
  // Load all pattern configuration entities.
  foreach (\Drupal::configFactory()->listAll('pathauto.pattern.') as $pattern_config_name) {
    $pattern_config = \Drupal::configFactory()->getEditable($pattern_config_name);

    // Loop patterns and swap the node_type plugin by the entity_bundle:node
    // plugin.
    if ($pattern_config->get('type') === 'canonical_entities:node') {
      $selection_criteria = $pattern_config->get('selection_criteria');
      foreach ($selection_criteria as $uuid => $condition) {
        if ($condition['id'] === 'node_type') {
          $pattern_config->set("selection_criteria.$uuid.id", 'entity_bundle:node');
          $pattern_config->save();
          break;
        }
      }
    }
  }
}

/**
 * Update listblock offsets.
 */
function sitenow_update_10002() {
  // Apply updates to all blocks that are styled using card styles.
  _update_all_blocks_by_plugin_id([
    'views_block:article_list_block-list_article',
    'views_block:people_list_block-list_card',
    'views_block:events_list_block-card_list',
  ], function (&$component, $block) {
    /** @var \Drupal\layout_builder\SectionComponent $component */
    $config = $component->getConfiguration();

    if (array_key_exists('pager_offset', $config)) {
      $config['pager_offset'] = (int) $config['pager_offset'];
      if ($config['pager_offset'] < 0) {
        $config['pager_offset'] = 0;
      }
      $component->setConfiguration($config);
    }
  });
}

/**
 * Update field_person_website to be checked in block configurations.
 */
function sitenow_update_10003() {
  foreach ([
    'views_block:people_list_block-list_card',
  ] as $block_plugin_id) {
    _update_all_blocks_by_plugin_id($block_plugin_id, function (&$component) {
      $config = $component->getConfiguration();
      if (isset($config['fields']['field_person_website'])) {

        $config['fields']['field_person_website']['hide'] = 1;
        $component->setConfiguration($config);
      }

    });
  }
}

/**
 * Convert <hr> with classes to <div> for CKEditor5 compatibility.
 *
 * For https://www.drupal.org/project/drupal/issues/3398223.
 */
function sitenow_update_10004() {
  $search_replace = [
    '<hr class=',
  ];

  $entity_type_manager = \Drupal::entityTypeManager();
  $entity_field_manager = \Drupal::service('entity_field.manager');
  $text_long = $entity_field_manager->getFieldMapByFieldType('text_long');
  $text_with_summary = $entity_field_manager->getFieldMapByFieldType('text_with_summary');
  $entity_field_map = array_merge($text_long, $text_with_summary);

  foreach ($entity_field_map as $entity_type_id => $field_map) {
    $entity_storage = $entity_type_manager->getStorage($entity_type_id);
    if (!($entity_storage instanceof SqlContentEntityStorage)) {
      continue;
    }

    $entity_type = $entity_type_manager->getDefinition($entity_type_id);
    $field_storage_definitions = $entity_field_manager->getFieldStorageDefinitions($entity_type_id);
    $table_mapping = $entity_storage->getTableMapping($field_storage_definitions);
    foreach (array_intersect_key($field_storage_definitions, $field_map) as $field_storage_definition) {
      $tables = [];
      $field_name = $field_storage_definition->getName();
      try {
        $tables[] = $table_mapping->getFieldTableName($field_name);
        $value_column = $table_mapping->getFieldColumnName($field_storage_definition, 'value');
      }
      catch (SqlContentEntityStorageException $e) {
        continue;
      }
      // See if the field has a revision table.
      $revision_table = NULL;
      if ($entity_type->isRevisionable() && $field_storage_definition->isRevisionable()) {
        if ($table_mapping->requiresDedicatedTableStorage($field_storage_definition)) {
          $revision_table = $table_mapping->getDedicatedRevisionTableName($field_storage_definition);
        }
        elseif ($table_mapping->allowsSharedTableStorage($field_storage_definition)) {
          $revision_table = $entity_type->getRevisionDataTable() ?: $entity_type->getRevisionTable();
        }
        $tables[] = $revision_table;
      }
      if (!empty($tables)) {
        $db = \Drupal::database();

        foreach ($tables as $table) {
          $update_count = 0;
          $query = $db->select($table, 't')
            ->fields('t');

          // Build a condition group from our search strings.
          $or_group = $query->orConditionGroup();

          foreach ($search_replace as $string) {
            $or_group->condition($value_column, '%' . $db->escapeLike($string) . '%', 'LIKE');
          }

          $results = $query->condition($or_group)
            ->execute();

          foreach ($results as $record) {

            // Load the HTML fragment as a DOMDocument object.
            $document = Html::load($record->{$value_column});

            // Loop through <hr> elements in dom and
            // replace with <div> if they have classes.
            $elements = $document->getElementsByTagName('hr');
            for ($i = $elements->length - 1; $i >= 0; $i--) {
              $hr = $elements->item($i);
              $class = $hr->getAttribute('class');
              if ($class) {
                $div = $document->createElement('div', $hr->nodeValue);
                $class = 'hr ' . $class;
                $div->setAttribute('class', $class);
                $hr->parentNode->replaceChild($div, $hr);
              }
            }

            // Run database update to store updated $value_column as
            // Html::serialize($document).
            $db->update($table)
              ->fields([
                $value_column => Html::serialize($document),
              ])
              ->condition('entity_id', $record->entity_id)
              ->condition('revision_id', $record->revision_id)
              ->execute();

            $update_count++;
          }

          if ($update_count) {
            \Drupal::messenger()
              ->addMessage('Processed ' . $update_count . ' update(s) for ' . $table . ' table ' . $value_column . ' column.');
          }
        }
      }
    }
  }
}

/**
 * Set new config value on existing sites.
 */
function sitenow_update_10005() {
  /** @var Drupal\Core\Config\ImmutableConfig $config */
  $ccom_config = \Drupal::service('config_split.manager')->getSplitConfig('config_split.config_split.ccom');
  // Set to 1 if the ccom config doesn't exist or isn't set,
  // otherwise set to 0.
  $value = (int) (!isset($ccom_config) || !$ccom_config->get('status'));

  // Set the uiowa_core setting so that the campus-wide
  // gtm will be included on page load.
  $config_factory = \Drupal::configFactory();
  $config = $config_factory->getEditable('uiowa_core.settings');
  $config->set('uiowa_core.campus_gtm', $value)
    ->save();
}

/**
 * Allow alert content type to be replicated if it exists.
 */
function sitenow_update_10006() {
  $config_factory = \Drupal::configFactory();
  $config = $config_factory->getEditable('uiowa_core.settings');
  $replicate_allowed = $config->get('uiowa_core.replicate_allowed');
  $replicate_allowed[] = 'alert';
  $config
    ->set('uiowa_core.replicate_allowed', $replicate_allowed)
    ->save();
}

/**
 * Fix block references that stored the wrong bundle class for pages.
 */
function sitenow_update_10007() {

  $block_plugin_ids = ['views_block:page_list_block-list_page'];
  $db = \Drupal::database();

  // Only continue with this section if we have a key_value_expire
  // table to work with.
  if ($db->schema()->tableExists('key_value_expire')) {
    // Directly accessing KVE record.
    $query = $db->select('key_value_expire', 'kve');

    $query = $query->condition('collection',
      'tempstore.shared.layout_builder.section_storage.overrides', '=')
      ->condition('value', '%uiowa_core%', 'LIKE')
      ->fields('kve');

    $count = $query->countQuery()->execute()->fetchField();

    \Drupal::messenger()
      ->addMessage(t('Tempstore records for layouts containing reference to incorrect page bundle class: @count',
        [
          '@types' => implode(', ', $block_plugin_ids),
          '@count' => $count,
        ]));

    $results = $query
      ->execute();

    foreach ($results as $record) {

      // Directly manipulating the string because we can't serialize this because the class doesn't exist anymore.
      $record->value = str_replace('Drupal\uiowa_core\Entity\Page', 'Drupal\sitenow_pages\Entity\Page', $record->value);

      // Insert the updated tempstore.
      $db->update('key_value_expire')
        ->condition('name', $record->name, '=')
        ->condition('expire', $record->expire, '=')
        ->fields([
          'value' => serialize($record->value),
        ])
        ->execute();
    }
  }

}
