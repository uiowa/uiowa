<?php

/**
 * @file
 * Primary module hooks for Uiowa Core module.
 */

use Drupal\Core\Entity\EntityInterface;
use Drupal\Core\Entity\FieldableEntityInterface;
use Drupal\Core\Field\FieldStorageDefinitionInterface;
use Drupal\Core\Form\FormStateInterface;
use Drupal\taxonomy\Entity\Term;

/**
 * Implements hook_form_alter().
 */
function classrooms_core_form_alter(&$form, FormStateInterface $form_state, $form_id) {
  switch ($form_id) {
    case 'node_room_form':
    case 'node_room_edit_form':
      _sitenow_node_form_defaults($form, $form_state);

      // These are imported fields that editors should not interact with.
      $form['field_room_name']['#disabled'] = TRUE;
      $form['field_room_features']['#disabled'] = TRUE;
      $form['field_room_technology_features']['#disabled'] = TRUE;
      $form['field_room_responsible_unit']['#disabled'] = TRUE;
      $form['field_room_type']['#disabled'] = TRUE;
      $form['field_room_instruction_category']['#disabled'] = TRUE;
      $form['field_room_max_occupancy']['#disabled'] = TRUE;
      $form['field_room_scheduling_regions']['#disabled'] = TRUE;
      break;

  }
}

/**
 * Set dynamic allowed values for the instructional room category field.
 *
 * @param \Drupal\Core\Field\FieldStorageDefinitionInterface $definition
 *   The field definition.
 * @param \Drupal\Core\Entity\FieldableEntityInterface|null $entity
 *   The entity being created if applicable.
 * @param bool $cacheable
 *   Boolean indicating if the results are cacheable.
 *
 * @return array
 *   An array of possible key and value options.
 *
 * @see options_allowed_values()
 */
function classrooms_core_room_category_allowed_values(FieldStorageDefinitionInterface $definition, FieldableEntityInterface $entity = NULL, bool &$cacheable = TRUE): array {
  $options = [
    'UNIVERSITY_CLASSROOM' => 'University Classroom',
    'PROGRAMMED_CLASSROOM' => 'Programmed Classroom',
  ];
  return $options;
}

/**
 * Implements hook_entity_presave().
 */
function classrooms_core_entity_presave(EntityInterface $entity): void {
  if (!$entity instanceof FieldableEntityInterface || $entity->bundle() !== 'room') {
    return;
  }

  $building_id = $entity
    ->field_room_building_id
    ?->target_id;
  $room_id = $entity
    ->field_room_room_id
    ?->value;

  if (!is_null($building_id) && !is_null($room_id)) {
    $building = Drupal::entityTypeManager()->getStorage('building')->load($building_id);

    // Set title programmatically based on building and room id.
    $title = "{$building->label()} $room_id";
    $entity->set('title', $title);
  }

  // Grab MAUI room data.
  $maui_api = \Drupal::service('uiowa_maui.api');
  $data = $maui_api->getRoomData($building_id, $room_id);
  if ($data) {
    // Mapping the Max Occupancy field to the maxOccupancy value from endpoint.
    if ($entity->hasField('field_room_max_occupancy') && isset($data[0]->maxOccupancy)) {
      if (filter_var($data[0]->maxOccupancy, FILTER_VALIDATE_INT) !== FALSE) {
        $entity->set('field_room_max_occupancy', $data[0]->maxOccupancy);
      }
    }

    // Mapping the Room Name field to the roomName value from endpoint.
    if ($entity->hasField('field_room_name') && isset($data[0]->roomName)) {
      if (strlen($data[0]->roomName) > 1) {
        $entity->set('field_room_name', $data[0]->roomName);
      }
    }

    // Mapping the Instructional Room Category field to the
    // roomCategory value from endpoint.
    if ($entity->hasField('field_room_instruction_category') && isset($data[0]->roomCategory)) {
      $field_definition = $entity->getFieldDefinition('field_room_instruction_category')->getFieldStorageDefinition();
      $field_allowed_options = options_allowed_values($field_definition, $entity);
      if (array_key_exists($data[0]->roomCategory, $field_allowed_options)) {
        $entity->set('field_room_instruction_category', $data[0]->roomCategory);
      }
    }

    // Mapping the Room Type field to the roomType value from endpoint.
    if ($entity->hasField('field_room_type') && isset($data[0]->roomType)) {
      // Returns all terms matching name within vocabulary.
      $term = \Drupal::entityTypeManager()
        ->getStorage('taxonomy_term')
        ->loadByProperties(['name' => $data[0]->roomType, 'vid' => 'room_types']);
      if (!empty($term)) {
        // Set based on first (and hopefully only) result.
        $entity->set('field_room_type', [array_key_first($term)]);
      }
      else {
        // If term does not exist create it.
        $new_term = Term::create([
          'vid' => 'room_types',
          'name' => $data[0]->roomType,
        ]);
        $new_term->save();
        $entity->set('field_room_type', [$new_term->id()]);
      }
    }

    // Mapping the Responsible Unit field to the
    // acadOrgUnitName value from endpoint.
    if ($entity->hasField('field_room_responsible_unit') && isset($data[0]->acadOrgUnitName)) {
      // Returns all terms matching name within vocabulary.
      $term = \Drupal::entityTypeManager()
        ->getStorage('taxonomy_term')
        ->loadByProperties([
          'name' => $data[0]->acadOrgUnitName,
          'vid' => 'units',
        ]);
      if (!empty($term)) {
        // Set based on first (and hopefully only) result.
        $entity->set('field_room_responsible_unit', [array_key_first($term)]);
      }
      else {
        // If term does not exist create it.
        $new_term = Term::create([
          'vid' => 'units',
          'name' => $data[0]->acadOrgUnitName,
        ]);
        $new_term->save();
        $entity->set('field_room_responsible_unit', [$new_term->id()]);
      }
    }

    // Mapping Room Features and Technology Features fields
    // to the featureList value from endpoint.
    if (isset($data[0]->featureList)) {
      $query = \Drupal::entityQuery('taxonomy_term')->orConditionGroup()
        ->condition('vid', 'room_features')
        ->condition('vid', 'technology_features');

      $tids = \Drupal::entityQuery('taxonomy_term')
        ->condition($query)
        ->execute();
      if ($tids) {
        $storage = \Drupal::entityTypeManager()->getStorage('taxonomy_term');
        $terms = $storage->loadMultiple($tids);
        $room_features = [];
        $tech_features = [];
        foreach ($terms as $term) {
          if ($api_mapping = $term->get('field_api_mapping')?->value) {
            if (in_array($api_mapping, $data[0]->featureList)) {
              if ($term->bundle() === 'room_features') {
                $room_features[] = $term->id();
              }
              else {
                $tech_features[] = $term->id();
              }
            }
          }
        }
        if (!empty($room_features)) {
          $entity->set('field_room_features', $room_features);
        }
        if (!empty($tech_features)) {
          $entity->set('field_room_technology_features', $tech_features);
        }
      }
    }

    // Mapping the Scheduling Regions field to the
    // regionList value from endpoint.
    if (isset($data[0]->regionList)) {
      $query = \Drupal::entityQuery('taxonomy_term')
        ->condition('vid', 'scheduling_regions')
        ->execute();

      if ($query) {
        $storage = \Drupal::entityTypeManager()->getStorage('taxonomy_term');
        $terms = $storage->loadMultiple($query);
        foreach ($terms as $term) {
          if ($api_mapping = $term->get('field_api_mapping')?->value) {
            if (in_array($api_mapping, $data[0]->regionList)) {
              $entity->set('field_room_scheduling_regions', $term->id());
              break;
            }
          }
        }
      }
    }
  }
}
