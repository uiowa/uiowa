<?php

/**
 * @file
 * Primary module hooks for Now Core module.
 */

use Drupal\Core\Form\FormStateInterface;

/**
 * Implements hook_form_alter().
 */
function now_core_form_alter(&$form, FormStateInterface $form_state, $form_id) {
  if ($form_id === 'node_article_form' || $form_id === 'node_article_edit_form') {
    $form['field_embargo_information']['#states'] = [
      'visible' => [
        ':input[name="field_article_type"]' => [
          'value' => 'news-feature',
        ],
      ],
    ];

    $form['field_original_publication_date']['#states'] = [
      'visible' => [
        ':input[name="field_article_type"]' => [
          ['value' => 'in-the-news'],
          'or',
          ['value' => 'spotlight'],
        ],
      ],
    ];

    // @todo Remove this when https://github.com/uiowa/uiowa/issues/2691
    //   is resolved.
    // Smart_date deals with ranges, but we only need a single date,
    // so unset the extra "to" in the form and hide the end date.
    // JS will update the end date to match the start date
    // without showing clutter to the end user.
    unset($form['field_original_publication_date']['widget'][0]['time_wrapper']['separator']);
    $form['field_original_publication_date']['widget'][0]['time_wrapper']['end_value']['#attributes']['class'][] = 'hidden';
  }
}

/**
 * Implements hook_ENTITY_TYPE_presave().
 */
function now_core_node_presave($entity) {
  // Currently we're only interested in altering
  // functionality for the articles, so return if not.
  if ($entity->getType() != 'article') {
    return;
  }

  // Add a tag according to the article type
  // so that it can be used in user-created filters.
  // @todo Decide if this should only be on new articles,
  //   or if it should always be a thing.
  if ($entity->isNew() && isset($entity->field_article_type)) {
    $tid = _article_type_tag_map($entity->field_article_type->value);
    if ($tid !== FALSE) {
      // Check that we didn't already have the tid
      // before appending it to our list of tags.
      $in_array = FALSE;
      foreach ($entity->field_tags->getValue() as $item) {
        if ($item['target_id'] == $tid) {
          $in_array = TRUE;
          break;
        }
      }
      if ($in_array === FALSE) {
        $entity->field_tags->appendItem($tid);
      }
    }
  }

  // The rest of the functionality only applies
  // to the news-feature article type, so we may be done.
  if (isset($entity->field_article_type) && $entity->field_article_type->value != 'news-feature') {
    return;
  }
  // If we don't have these, there's no functionality to alter.
  if (!isset($entity->moderation_state) || !isset($entity->field_embargo_information)) {
    return;
  }
  // We only need to change things if there is both
  // an embargo message present and we are trying to publish.
  if (!empty($entity->field_embargo_information->value)) {
    if ($entity->moderation_state->value != 'published') {
      return;
    }
    // If it's brand new, then we'll go ahead and set it to draft
    // rather than publish.
    if ($entity->isNew()) {
      $alt_state = 'draft';
    }
    // If it's not new, then let's set it back to it's previous state
    // which wasn't published.
    else {
      // If we are not going from a previously published state,
      // set it to the old mod state (eg draft or review).
      // In the case where the previous state was published,
      // we default to archived to unpublish the page.
      // There shouldn't be a case where this happens unless it is
      // by accident, so this is really only a fallback.
      $alt_state = ($entity->original->moderation_state->value == 'published') ? 'archived' : $entity->original->moderation_state->value;
    }
    $entity->moderation_state = $alt_state;
    // Add a user message along with changing this state.
    \Drupal::messenger()->addWarning(
      t("Content is under embargo and cannot be published at this time. It has been set to the @alt_state moderation state.",
        [
          '@alt_state' => $alt_state,
        ])
    );
  }
}

/**
 * Mapping for article types to their associated tags.
 *
 * @param string $article_type
 *   The article type as a machine name.
 *
 * @return int|bool
 *   The associated TID or FALSE.
 */
function _article_type_tag_map(string $article_type) {
  $map = [
    'achievement' => 16,
    'news-feature' => 11,
    'in-the-news' => 21,
    'spotlight' => 31,
  ];
  return $map[$article_type] ?? FALSE;
}
